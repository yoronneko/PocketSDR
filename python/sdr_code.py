#
#  Pocket SDR Python Library - GNSS Spreading Code Functions
#
#  References:
#  [1] IS-GPS-200K, NAVSTAR GPS Space Segment/Navigation User Segment
#      Interfaces, May 19, 2019
#  [2] IS-GPS-705A, Navstar GPS Space Segment / User Segment L5 Interfaces,
#      June 8, 2010
#  [3] IS-QZSS-PNT-004, Quasi-Zenith Satellite System Interface Specification
#      Satellite Positioning, Navigation and Timing Service, November 5, 2018
#  [4] IS-QZSS-L6-005, Quasi-Zenith Satellite System Interface Specification
#      Centimeter Level Augmentation Service, September 21, 2022
#  [5] Galileo Open Service Signal In Space Interface Control Document -
#      Issue 1, February 2010
#  [6] Galileo E6-B/C Codes Technical Note - Issue 1, January 2019
#  [7] IS-GPS-800F, Navstar GPS Space Segment / User Segment L1C Interfaces,
#      March 4, 2019
#  [8] BeiDou Navigation Satellite System Signal In Space Interface Control
#      Document - Open Service Signal B1C (Version 1.0), December, 2017
#  [9] BeiDou Navigation Satellite System Signal In Space Interface Control
#      Document - Open Service Signal B2a (Version 1.0), December, 2017
#  [10] BeiDou Navigation Satellite System Signal In Space Interface Control
#      Document - Open Service Signal B2b (Version 1.0), July, 2020
#  [11] BeiDou Navigation Satellite System Signal In Space Interface Control
#      Document - Precise Positioning Service Signal PPP-B2b (Version 1.0),
#      July, 2020
#  [12] BeiDou Navigation Satellite System Signal In Space Interface Control
#      Document - Open Service Signal B1I (Version 3.0), February, 2019
#  [13] BeiDou Navigation Satellite System Signal In Space Interface Control
#      Document - Open Service Signal B3I (Version 1.0), February, 2018
#  [14] Global Navigation Satellite System GLONASS Interface Control Document
#      Navigation radiosignal in bands L1, L2 (Version 5.1), 2008
#  [15] IS-QZSS-TV-004, Quasi-Zenith Satellite System Interface Specification
#      Positioning Technology Verification Service, September 27, 2023
#  [16] IRNSS SIS ICD for Standard Positioning Service version 1.1, August,
#      2017
#  [17] GLONASS Interface Control Document Code Division Multiple Access Open
#      Service Navigation Signal in L3 frequency band Edition 1.0, 2016
#  [18] NavIC Signal in Space ICD for Standard Positioning Service in L1
#      Frequency version 1.0, August, 2023
#  [19] GLONASS Interface Control Document Code Division Multiple Access Open
#      Service Navigation Signal in L1 frequency band Edition 1.0, 2016
#  [20] GLONASS Interface Control Document Code Division Multiple Access Open
#      Service Navigation Signal in L2 frequency band Edition 1.0, 2016
#
#  Author:
#  T.TAKASU
#
#  History:
#  2021-12-01  1.0  new
#  2021-12-05  1.1  add signals: G1CA, G2CA, B1I, B2I, B1CD, B1CP, B2AD, B2AP,
#                   B2BI, B3I
#  2021-12-22  1.2  add secondary code generation
#  2021-12-24  1.3  add L1S, L5SI, L5SQ
#  2022-01-13  1.4  change API gen_code_fft()
#                   add support of G1CA, G2CA and B3I in sec_code()
#  2022-01-17  1.5  add signals: L2CL, I5S, ISS
#  2022-01-27  1.6  add signals: G3OCD, G3OCP
#  2022-05-17  1.7  fix bug on gen_code_ISS()
#  2023-12-28  1.8  L5S PRN range: 184-189 -> 184-189,205-206 [15]
#                   add signal L5SIV (L5SI verification mode)
#  2024-01-03  1.9  add secondary code of G1CA with odd FCN
#  2024-01-04  1.10 add signal L5SQV (L5SQ verification mode)
#                   fix L5Q SBAS secondary code
#  2024-01-06  1.11 add signal I1SD, I1SP
#  2024-01-07  1.12 add signal G1OCD, G1OCP, G2OCP
#  2024-01-12  1.13 add API sat_id()
#
import numpy as np
import scipy.fftpack as fft
import sdr_func, sdr_code_gal

# constants --------------------------------------------------------------------
NONE = np.array([], dtype='int8')
CHIP = (-1, 1)

# code caches ------------------------------------------------------------------
L1CA       = {}
L1CP, L1CD = {}, {}
L1CO       = {}
L2CM, L2CL = {}, {}
L5I , L5Q  = {}, {}
L6D,  L6E  = {}, {}
G1CA       = {}
G1OCD, G1OCP = {}, {}
G2OCP      = {}
G3OCD, G3OCP = {}, {}
E1B , E1C  = {}, {}
E5AI, E5AQ = {}, {}
E5BI, E5BQ = {}, {}
E6B , E6C  = {}, {}
B1I        = {}
B1CD, B1CP = {}, {}
B1CS       = {}
B2AD, B2AP = {}, {}
B2AS       = {}
B2BI       = {}
B3I        = {}
I1SD       = {}
I1SP       = {}
I1SPO      = {}
I5S        = {}
ISS        = {}

L1CA_G1, L1CA_G2 = [], []
L1C_L_SEQ = []
L5_XA, L5_XB = [], []
G3OC_D1 = []
B1C_L_SEQ, B1C_L_SEQ_S = [], []
B2AD_G1, B2AP_G1 = [], []
B2A_L_SEQ = []
B2BI_G1 = []
B3I_G1 = []

# code tables ------------------------------------------------------------------
L1CA_G2_delay = ( # PRN 1 - 210
       5,   6,   7,   8,  17,  18, 139, 140, 141, 251, 252, 254, 255, 256, 257,
     258, 469, 470, 471, 472, 473, 474, 509, 512, 513, 514, 515, 516, 859, 860,
     861, 862, 863, 950, 947, 948, 950,  67, 103,  91,  19, 679, 225, 625, 946,
     638, 161,1001, 554, 280, 710, 709, 775, 864, 558, 220, 397,  55, 898, 759,
     367, 299,1018, 729, 695, 780, 801, 788, 732,  34, 320, 327, 389, 407, 525,
     405, 221, 761, 260, 326, 955, 653, 699, 422, 188, 438, 959, 539, 879, 677,
     586, 153, 792, 814, 446, 264,1015, 278, 536, 819, 156, 957, 159, 712, 885,
     461, 248, 713, 126, 807, 279, 122, 197, 693, 632, 771, 467, 647, 203, 145,
     175,  52,  21, 237, 235, 886, 657, 634, 762, 355,1012, 176, 603, 130, 359,
     595,  68, 386, 797, 456, 499, 883, 307, 127, 211, 121, 118, 163, 628, 853,
     484, 289, 811, 202,1021, 463, 568, 904, 670, 230, 911, 684, 309, 644, 932,
      12, 314, 891, 212, 185, 675, 503, 150, 395, 345, 846, 798, 992, 357, 995,
     877, 112, 144, 476, 193, 109, 445, 291,  87, 399, 292, 901, 339, 208, 711,
     189, 263, 537, 663, 942, 173, 900,  30, 500, 935, 556, 373,  85, 652, 310)

L1CP_weil_idx = ( # PRN 1 - 210
    5111, 5109, 5108, 5106, 5103, 5101, 5100, 5098, 5095, 5094, 5093, 5091,
    5090, 5081, 5080, 5069, 5068, 5054, 5044, 5027, 5026, 5014, 5004, 4980,
    4915, 4909, 4893, 4885, 4832, 4824, 4591, 3706, 5092, 4986, 4965, 4920,
    4917, 4858, 4847, 4790, 4770, 4318, 4126, 3961, 3790, 4911, 4881, 4827,
    4795, 4789, 4725, 4675, 4539, 4535, 4458, 4197, 4096, 3484, 3481, 3393,
    3175, 2360, 1852, 5065, 5063, 5055, 5012, 4981, 4952, 4934, 4932, 4786,
    4762, 4640, 4601, 4563, 4388, 3820, 3687, 5052, 5051, 5047, 5039, 5015,
    5005, 4984, 4975, 4974, 4972, 4962, 4913, 4907, 4903, 4833, 4778, 4721,
    4661, 4660, 4655, 4623, 4590, 4548, 4461, 4442, 4347, 4259, 4256, 4166,
    4155, 4109, 4100, 4023, 3998, 3979, 3903, 3568, 5088, 5050, 5020, 4990,
    4982, 4966, 4949, 4947, 4937, 4935, 4906, 4901, 4872, 4865, 4863, 4818,
    4785, 4781, 4776, 4775, 4754, 4696, 4690, 4658, 4607, 4599, 4596, 4530,
    4524, 4451, 4441, 4396, 4340, 4335, 4296, 4267, 4168, 4149, 4097, 4061,
    3989, 3966, 3789, 3775, 3622, 3523, 3515, 3492, 3345, 3235, 3169, 3157,
    3082, 3072, 3032, 3030, 4582, 4595, 4068, 4871, 4514, 4439, 4122, 4948,
    4774, 3923, 3411, 4745, 4195, 4897, 3047, 4185, 4354, 5077, 4042, 2111,
    4311, 5024, 4352, 4678, 5034, 5085, 3646, 4868, 3668, 4211, 2883, 2850,
    2815, 2542, 2492, 2376, 2036, 1920)

L1CP_ins_idx = ( # PRN 1 - 210
     412,  161,    1,  303,  207, 4971, 4496,    5, 4557,  485,  253, 4676,
       1,   66, 4485,  282,  193, 5211,  729, 4848,  982, 5955, 9805,  670,
     464,   29,  429,  394,  616, 9457, 4429, 4771,  365, 9705, 9489, 4193,
    9947,  824,  864,  347,  677, 6544, 6312, 9804,  278, 9461,  444, 4839,
    4144, 9875,  197, 1156, 4674,10035, 4504,    5, 9937,  430,    5,  355,
     909, 1622, 6284, 9429,   77,  932, 5973,  377,10000,  951, 6212,  686,
    9352, 5999, 9912, 9620,  635, 4951, 5453, 4658, 4800,   59,  318,  571,
     565, 9947, 4654,  148, 3929,  293,  178,10142, 9683,  137,  565,   35,
    5949,    2, 5982,  825, 9614, 9790, 5613,  764,  660, 4870, 4950, 4881,
    1151, 9977, 5122,10074, 4832,   77, 4698, 1002, 5549, 9606, 9228,  604,
    4678, 4854, 4122, 9471, 5026,  272, 1027,  317,  691,  509, 9708, 5033,
    9938, 4314,10140, 4790, 9823, 6093,  469, 1215,  799,  756, 9994, 4843,
    5271, 9661, 6255, 5203,  203,10070,   30,  103, 5692,   32, 9826,   76,
      59, 6831,  958, 1471,10070,  553, 5487,   55,  208,  645, 5268, 1873,
     427,  367, 1404, 5652,    5,  368,  451, 9595, 1030, 1324,  692, 9819,
    4520, 9911,  278,  642, 6330, 5508, 1872, 5445,10131,  422, 4918,  787,
    9864, 9753, 9859,  328,    1, 4733, 164,   135,  174,  132,  538,  176,
     198,  595,  574,  321,  596,  491)

L1CD_weil_idx = ( # PRN 1 - 210
    5097, 5110, 5079, 4403, 4121, 5043, 5042, 5104, 4940, 5035, 4372, 5064,
    5084, 5048, 4950, 5019, 5076, 3736, 4993, 5060, 5061, 5096, 4983, 4783,
    4991, 4815, 4443, 4769, 4879, 4894, 4985, 5056, 4921, 5036, 4812, 4838,
    4855, 4904, 4753, 4483, 4942, 4813, 4957, 4618, 4669, 4969, 5031, 5038,
    4740, 4073, 4843, 4979, 4867, 4964, 5025, 4579, 4390, 4763, 4612, 4784,
    3716, 4703, 4851, 4955, 5018, 4642, 4840, 4961, 4263, 5011, 4922, 4317,
    3636, 4884, 5041, 4912, 4504, 4617, 4633, 4566, 4702, 4758, 4860, 3962,
    4882, 4467, 4730, 4910, 4684, 4908, 4759, 4880, 4095, 4971, 4873, 4561,
    4588, 4773, 4997, 4583, 4900, 4574, 4629, 4676, 4181, 5057, 4944, 4401,
    4586, 4699, 3676, 4387, 4866, 4926, 4657, 4477, 4359, 4673, 4258, 4447,
    4570, 4486, 4362, 4481, 4322, 4668, 3967, 4374, 4553, 4641, 4215, 3853,
    4787, 4266, 4199, 4545, 4208, 4485, 3714, 4407, 4182, 4203, 3788, 4471,
    4691, 4281, 4410, 3953, 3465, 4801, 4278, 4546, 3779, 4115, 4193, 3372,
    3786, 3491, 3812, 3594, 4028, 3652, 4224, 4334, 3245, 3921, 3840, 3514,
    2922, 4227, 3376, 3560, 4989, 4756, 4624, 4446, 4174, 4551, 3972, 4399,
    4562, 3133, 4157, 5053, 4536, 5067, 3905, 3721, 3787, 4674, 3436, 2673,
    4834, 4456, 4056, 3804, 3672, 4205, 3348, 4152, 3883, 3473, 3669, 3455,
    2318, 2945, 2947, 3220, 4052, 2953)

L1CD_ins_idx = ( # PRN 1 - 210
     181,  359,   72, 1110, 1480, 5034, 4622,    1, 4547,  826, 6284, 4195,
     368,    1, 4796,  523,  151,  713, 9850, 5734,   34, 6142,  190,  644,
     467, 5384,  801,  594, 4450, 9437, 4307, 5906,  378, 9448, 9432, 5849,
    5547, 9546, 9132,  403, 3766,    3,  684, 9711,  333, 6124,10216, 4251,
    9893, 9884, 4627, 4449, 9798,  985, 4272,  126,10024,  434, 1029,  561,
     289,  638, 4353, 9899, 4629,  669, 4378, 4528, 9718, 5485, 6222,  672,
    1275, 6083, 5264,10167, 1085,  194, 5012, 4938, 9356, 5057,  866,    2,
     204, 9808, 4365,  162,  367,  201,   18,  251,10167,   21,  685,   92,
    1057,    3, 5756,   14, 9979, 9569,  515,  753, 1181, 9442,  669, 4834,
     541, 9933, 6683, 4828, 9710,10170, 9629,  260,   86, 5544,  923,  257,
     507, 4572, 4491,  341,  130,   79, 1142,  448,  875,  555, 1272, 5198,
    9529, 4459,10019, 9353, 9780,  375,  503, 4507,  875, 1246,    1, 4534,
       8, 9549, 6240,   22, 5652,10069, 4796, 4980,   27,   90, 9788,  715,
    9720,  301, 5450, 5215,   13, 1147, 4855, 1190, 1267, 1302,    1, 5007,
     549,  368, 6300, 5658, 4302,  851, 4353, 9618, 9652, 1232,  109,10174,
    6178, 1851, 1299,  325,10206, 9968,10191, 5438,10080,  219,  758, 2140,
    9753, 4799,10126,  241, 1245, 1274, 1456, 9967,  235,  512, 1078, 1078,
     953, 5647,  669, 1311, 5827,   15) 

L1CO_S1_poly = ( # PRN 1 - 210
    0o5111, 0o5421, 0o5501, 0o5403, 0o6417, 0o6141, 0o6351, 0o6501, 0o6205,
    0o6235, 0o7751, 0o6623, 0o6733, 0o7627, 0o5667, 0o5051, 0o7665, 0o6325,
    0o4365, 0o4745, 0o7633, 0o6747, 0o4475, 0o4225, 0o7063, 0o4423, 0o6651,
    0o4161, 0o7237, 0o4473, 0o5477, 0o6163, 0o7223, 0o6323, 0o7125, 0o7035,
    0o4341, 0o4353, 0o4107, 0o5735, 0o6741, 0o7071, 0o4563, 0o5755, 0o6127,
    0o4671, 0o4511, 0o4533, 0o5357, 0o5607, 0o6673, 0o6153, 0o7565, 0o7107,
    0o6211, 0o4321, 0o7201, 0o4451, 0o5411, 0o5141, 0o7041, 0o6637, 0o4577,
    0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111,
    0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111,
    0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111,
    0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111, 0o5111,
    0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421,
    0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421,
    0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421,
    0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421, 0o5421,
    0o5421, 0o5421, 0o5421, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403,
    0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403,
    0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403,
    0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403,
    0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403,
    0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403,
    0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o5403, 0o6501,
    0o6501, 0o6501, 0o6501, 0o6501, 0o6501, 0o6501, 0o6501, 0o6501, 0o6501,
    0o6501, 0o6501, 0o6501)

L1CO_S1_init = ( # PRN 1 - 210
    0o3266, 0o2040, 0o1527, 0o3307, 0o3756, 0o3026, 0o0562, 0o0420, 0o3415,
    0o0337, 0o0265, 0o1230, 0o2204, 0o1440, 0o2412, 0o3516, 0o2761, 0o3750,
    0o2701, 0o1206, 0o1544, 0o1774, 0o0546, 0o2213, 0o3707, 0o2051, 0o3650,
    0o1777, 0o3203, 0o1762, 0o2100, 0o0571, 0o3710, 0o3535, 0o3110, 0o1426,
    0o0255, 0o0321, 0o3124, 0o0572, 0o1736, 0o3306, 0o1307, 0o3763, 0o1604,
    0o1021, 0o2624, 0o0406, 0o0114, 0o0077, 0o3477, 0o1000, 0o3460, 0o2607,
    0o2057, 0o3467, 0o0706, 0o2032, 0o1464, 0o0520, 0o1766, 0o3270, 0o0341,
    0o1740, 0o3664, 0o1427, 0o2627, 0o0701, 0o3460, 0o1373, 0o2540, 0o2004,
    0o2274, 0o1340, 0o0602, 0o2502, 0o0327, 0o2600, 0o0464, 0o3674, 0o3040,
    0o1153, 0o0747, 0o1770, 0o3772, 0o1731, 0o1672, 0o1333, 0o2705, 0o2713,
    0o3562, 0o3245, 0o3770, 0o3202, 0o3521, 0o3250, 0o2117, 0o0530, 0o3021,
    0o2511, 0o1562, 0o1067, 0o0424, 0o3402, 0o1326, 0o2142, 0o0733, 0o0504,
    0o1611, 0o2724, 0o0753, 0o3724, 0o2652, 0o1743, 0o0013, 0o3464, 0o2300,
    0o1334, 0o2175, 0o2564, 0o3075, 0o3455, 0o3627, 0o0617, 0o1324, 0o3506,
    0o2231, 0o1110, 0o1271, 0o3740, 0o3652, 0o1644, 0o3635, 0o3436, 0o3076,
    0o0434, 0o3340, 0o0054, 0o2446, 0o0025, 0o0150, 0o2746, 0o2723, 0o2601,
    0o3440, 0o1312, 0o0544, 0o2062, 0o0176, 0o3616, 0o1740, 0o3777, 0o0432,
    0o2466, 0o1667, 0o3601, 0o2706, 0o2022, 0o1363, 0o2331, 0o3556, 0o2205,
    0o3734, 0o2115, 0o0010, 0o2140, 0o3136, 0o0272, 0o3264, 0o2017, 0o2505,
    0o3532, 0o0647, 0o1542, 0o2154, 0o3734, 0o2621, 0o2711, 0o0217, 0o3503,
    0o3457, 0o3750, 0o2525, 0o0113, 0o0265, 0o1711, 0o0552, 0o0675, 0o1706,
    0o3513, 0o1135, 0o0566, 0o0500, 0o0254, 0o3445, 0o2542, 0o1257, 0o0211,
    0o0534, 0o1420, 0o3401, 0o0714, 0o0613, 0o2475, 0o2572, 0o3265, 0o1250,
    0o1711, 0o2704, 0o0135)

L1CO_S2_init = ( # 64 - 210
    0o3035, 0o1557, 0o0237, 0o2527, 0o3307, 0o1402, 0o1225, 0o0607, 0o0351,
    0o3724, 0o1675, 0o2625, 0o1030, 0o1443, 0o3277, 0o1132, 0o0572, 0o1241,
    0o0535, 0o1366, 0o0041, 0o0561, 0o0122, 0o1205, 0o3753, 0o2543, 0o3031,
    0o2260, 0o3773, 0o3156, 0o2215, 0o0146, 0o2413, 0o2564, 0o3310, 0o2267,
    0o3120, 0o0064, 0o1042, 0o0476, 0o1020, 0o0431, 0o0216, 0o2736, 0o2527,
    0o2431, 0o1013, 0o0524, 0o0726, 0o1042, 0o3362, 0o1364, 0o3354, 0o0623,
    0o0145, 0o0214, 0o0223, 0o0151, 0o2405, 0o2522, 0o3235, 0o0452, 0o2617,
    0o1300, 0o1430, 0o0773, 0o0772, 0o3561, 0o0607, 0o0420, 0o0527, 0o3770,
    0o2536, 0o2233, 0o3366, 0o3766, 0o3554, 0o2060, 0o2070, 0o0713, 0o3366,
    0o3247, 0o2776, 0o1244, 0o2102, 0o1712, 0o1245, 0o3344, 0o1277, 0o0165,
    0o2131, 0o3623, 0o0141, 0o0421, 0o3032, 0o2065, 0o3024, 0o2663, 0o2274,
    0o2114, 0o1664, 0o0413, 0o1512, 0o0135, 0o2737, 0o1015, 0o1075, 0o1255,
    0o3473, 0o2716, 0o0101, 0o1105, 0o1407, 0o3407, 0o1046, 0o3237, 0o0154,
    0o3010, 0o2245, 0o2051, 0o2144, 0o1743, 0o2511, 0o3410, 0o1414, 0o1275,
    0o2257, 0o2331, 0o0276, 0o3261, 0o1760, 0o0430, 0o3477, 0o1676, 0o1636,
    0o2411, 0o1473, 0o2266, 0o2104, 0o2070, 0o1766, 0o0711, 0o2533, 0o0353,
    0o1744, 0o0053, 0o2222) 

L2CM_R_init_1 = ( # PRN 1 - 63
    0o742417664, 0o756014035, 0o002747144, 0o066265724, 0o601403471,
    0o703232733, 0o124510070, 0o617316361, 0o047541621, 0o733031046,
    0o713512145, 0o024437606, 0o021264003, 0o230655351, 0o001314400,
    0o222021506, 0o540264026, 0o205521705, 0o064022144, 0o120161274,
    0o044023533, 0o724744327, 0o045743577, 0o741201660, 0o700274134,
    0o010247261, 0o713433445, 0o737324162, 0o311627434, 0o710452007,
    0o722462133, 0o050172213, 0o500653703, 0o755077436, 0o136717361,
    0o756675453, 0o435506112, 0o771353753, 0o226107701, 0o022025110,
    0o402466344, 0o752566114, 0o702011164, 0o041216771, 0o047457275,
    0o266333164, 0o713167356, 0o060546335, 0o355173035, 0o617201036,
    0o157465571, 0o767360553, 0o023127030, 0o431343777, 0o747317317,
    0o045706125, 0o002744276, 0o060036467, 0o217744147, 0o603340174,
    0o326616775, 0o063240065, 0o111460621)

L2CM_R_init_2 = ( # PRN 159 - 210
    0o604055104, 0o157065232, 0o013305707, 0o603552017, 0o230461355,
    0o603653437, 0o652346475, 0o743107103, 0o401521277, 0o167335110,
    0o014013575, 0o362051132, 0o617753265, 0o216363634, 0o755561123,
    0o365304033, 0o625025543, 0o054420334, 0o415473671, 0o662364360,
    0o373446602, 0o417564100, 0o000526452, 0o226631300, 0o113752074,
    0o706134401, 0o041352546, 0o664630154, 0o276524255, 0o714720530,
    0o714051771, 0o044526647, 0o207164322, 0o262120161, 0o204244652,
    0o202133131, 0o714351204, 0o657127260, 0o130567507, 0o670517677,
    0o607275514, 0o045413633, 0o212645405, 0o613700455, 0o706202440,
    0o705056276, 0o020373522, 0o746013617, 0o132720621, 0o434015513,
    0o566721727, 0o140633660)

L2CL_R_init_1 = ( # PRN 1 - 63
    0o624145772, 0o506610362, 0o220360016, 0o710406104, 0o001143345,
    0o053023326, 0o652521276, 0o206124777, 0o015563374, 0o561522076,
    0o023163525, 0o117776450, 0o606516355, 0o003037343, 0o046515565,
    0o671511621, 0o605402220, 0o002576207, 0o525163451, 0o266527765,
    0o006760703, 0o501474556, 0o743747443, 0o615534726, 0o763621420,
    0o720727474, 0o700521043, 0o222567263, 0o132765304, 0o746332245,
    0o102300466, 0o255231716, 0o437661701, 0o717047302, 0o222614207,
    0o561123307, 0o240713073, 0o101232630, 0o132525726, 0o315216367,
    0o377046065, 0o655351360, 0o435776513, 0o744242321, 0o024346717,
    0o562646415, 0o731455342, 0o723352536, 0o000013134, 0o011566642,
    0o475432222, 0o463506741, 0o617127534, 0o026050332, 0o733774235,
    0o751477772, 0o417631550, 0o052247456, 0o560404163, 0o417751005,
    0o004302173, 0o715005045, 0o001154457)

L2CL_R_init_2 = ( # PRN 159 - 210
    0o605253024, 0o063314262, 0o066073422, 0o737276117, 0o737243704,
    0o067557532, 0o227354537, 0o704765502, 0o044746712, 0o720535263,
    0o733541364, 0o270060042, 0o737176640, 0o133776704, 0o005645427,
    0o704321074, 0o137740372, 0o056375464, 0o704374004, 0o216320123,
    0o011322115, 0o761050112, 0o725304036, 0o721320336, 0o443462103,
    0o510466244, 0o745522652, 0o373417061, 0o225526762, 0o047614504,
    0o034730440, 0o453073141, 0o533654510, 0o377016461, 0o235525312,
    0o507056307, 0o221720061, 0o520470122, 0o603764120, 0o145604016,
    0o051237167, 0o033326347, 0o534627074, 0o645230164, 0o000171400,
    0o022715417, 0o135471311, 0o137422057, 0o714426456, 0o640724672,
    0o501254540, 0o513322453)

L5I_XB_adv = ( # PRN 1 - 210
     266,  365,  804, 1138, 1509, 1559, 1756, 2084, 2170, 2303, 2527, 2687,
    2930, 3471, 3940, 4132, 4332, 4924, 5343, 5443, 5641, 5816, 5898, 5918,
    5955, 6243, 6345, 6477, 6518, 6875, 7168, 7187, 7329, 7577, 7720, 7777,
    8057, 5358, 3550, 3412,  819, 4608, 3698,  962, 3001, 4441, 4937, 3717,
    4730, 7291, 2279, 7613, 5723, 7030, 1475, 2593, 2904, 2056, 2757, 3756,
    6205, 5053, 6437, 7789, 2311, 7432, 5155, 1593, 5841, 5014, 1545, 3016,
    4875, 2119,  229, 7634, 1406, 4506, 1819, 7580, 5446, 6053, 7958, 5267,
    2956, 3544, 1277, 2996, 1758, 3360, 2718, 3754, 7440, 2781, 6756, 7314,
     208, 5252,  696,  527, 1399, 5879, 6868,  217, 7681, 3788, 1337, 2424,
    4243, 5686, 1955, 4791,  492, 1518, 6566, 5349,  506,  113, 1953, 2797,
     934, 3023, 3632, 1330, 4909, 4867, 1183, 3990, 6217, 1224, 1733, 2319,
    3928, 2380,  841, 5049, 7027, 1197, 7208, 8000,  152, 6762, 3745, 4723,
    5502, 4796,  123, 8142, 5091, 7875,  330, 5272, 4912,  374, 2045, 6616,
    6321, 7605, 2570, 2419, 1234, 1922, 4317, 5110,  825,  958, 1089, 7813,
    6058, 7703, 6702, 1714, 6371, 2281, 1986, 6282, 3201, 3760, 1056, 6233,
    1150, 2823, 6250,  645, 2401, 1639, 2946, 7091,  923, 7045, 6493, 1706,
    5836,  926, 6086,  950, 5905, 3240, 6675, 3197, 1555, 3589, 4555, 5671,
    6948, 4664, 2086, 5950, 5521, 1515)

L5Q_XB_adv = ( # PRN 1 - 210
    1701,  323, 5292, 2020, 5429, 7136, 1041, 5947, 4315,  148,  535, 1939,
    5206, 5910, 3595, 5135, 6082, 6990, 3546, 1523, 4548, 4484, 1893, 3961,
    7106, 5299, 4660,  276, 4389, 3783, 1591, 1601,  749, 1387, 1661, 3210,
     708, 4226, 5604, 6375, 3056, 1772, 3662, 4401, 5218, 2838, 6913, 1685,
    1194, 6963, 5001, 6694,  991, 7489, 2441,  639, 2097, 2498, 6470, 2399,
     242, 3768, 1186, 5246, 4259, 5907, 3870, 3262, 7387, 3069, 2999, 7993,
    7849, 4157, 5031, 5986, 4833, 5739, 7846,  898, 2022, 7446, 6404,  155,
    7862, 7795, 6121, 4840, 6585,  429, 6020,  200, 1664, 1499, 7298, 1305,
    7323, 7544, 4438, 2485, 3387, 7319, 1853, 5781, 1874, 7555, 2132, 6441,
    6722, 1192, 2588, 2188,  297, 1540, 4138, 5231, 4789,  659,  871, 6837,
    1393, 7383,  611, 4920, 5416, 1611, 2474,  118, 1382, 1092, 7950, 7223,
    1769, 4721, 1252, 5147, 2165, 7897, 4054, 3498, 6571, 2858, 8126, 7017,
    1901,  181, 1114, 5195, 7479, 4186, 3904, 7128, 1396, 4513, 5967, 2580,
    2575, 7961, 2598, 4508, 2090, 3685, 7748,  684,  913, 5558, 2894, 5858,
    6432, 3813, 3573, 7523, 5280, 3376, 7424, 2918, 5793, 1747, 7079, 2921,
    2490, 4119, 3373,  977,  681, 4273, 5419, 5626, 1266, 5804, 2414, 6444,
    4757,  427, 5452, 5182, 6606, 6531, 4268, 3115, 6835,  862, 4856, 2765,
      37, 1943, 7977, 2512, 4451, 4071)

L6D_R_init = ( # PRN 193 - 202
    0o00255021, 0o00327455, 0o00531421, 0o00615350, 0o00635477, 0o01547457,
    0o01715254, 0o01741247, 0o02322713, 0o02534561)

L6E_R_init = ( # PRN 203 - 212
    0o01142153, 0o01723711, 0o03672765, 0o00030404, 0o00000546, 0o01306224,
    0o03642512, 0o00255043, 0o02020075, 0o03571777)

E5AI_X2_init = ( # PRN 1 - 50
    0o30305, 0o14234, 0o27213, 0o20577, 0o23312, 0o33463, 0o15614, 0o12537,
    0o01527, 0o30236, 0o27344, 0o07272, 0o36377, 0o17046, 0o06434, 0o15405,
    0o24252, 0o11631, 0o24776, 0o00630, 0o11560, 0o17272, 0o27445, 0o31702,
    0o13012, 0o14401, 0o34727, 0o22627, 0o30623, 0o27256, 0o01520, 0o14211,
    0o31465, 0o22164, 0o33516, 0o02737, 0o21316, 0o35425, 0o35633, 0o24655,
    0o14054, 0o27027, 0o06604, 0o31455, 0o34465, 0o25273, 0o20763, 0o31721,
    0o17312, 0o13277)

E5AQ_X2_init = ( # PRN 1 - 50
    0o25652, 0o05142, 0o24723, 0o31751, 0o27366, 0o24660, 0o33655, 0o27450,
    0o07626, 0o01705, 0o12717, 0o32122, 0o16075, 0o16644, 0o37556, 0o02477,
    0o02265, 0o06430, 0o25046, 0o12735, 0o04262, 0o11230, 0o00037, 0o06137,
    0o04312, 0o20606, 0o11162, 0o22252, 0o30533, 0o24614, 0o07767, 0o32705,
    0o05052, 0o27553, 0o03711, 0o02041, 0o34775, 0o05274, 0o37356, 0o16205,
    0o36270, 0o06600, 0o26773, 0o17375, 0o35267, 0o36255, 0o12044, 0o26442,
    0o21621, 0o25411)

E5BI_X2_init = ( # PRN 1 - 50
    0o07220, 0o26047, 0o00252, 0o17166, 0o14161, 0o02540, 0o01537, 0o26023,
    0o01725, 0o20637, 0o02364, 0o27731, 0o30640, 0o34174, 0o06464, 0o07676,
    0o32231, 0o10353, 0o00755, 0o26077, 0o11644, 0o11537, 0o35115, 0o20452,
    0o34645, 0o25664, 0o21403, 0o32253, 0o02337, 0o30777, 0o27122, 0o22377,
    0o36175, 0o33075, 0o33151, 0o13134, 0o07433, 0o10216, 0o35466, 0o02533,
    0o05351, 0o30121, 0o14010, 0o32576, 0o30326, 0o37433, 0o26022, 0o35770,
    0o06670, 0o12017)

E5BQ_X2_init = ( # PRN 1 - 50
    0o03331, 0o06143, 0o25322, 0o23371, 0o00413, 0o36235, 0o17750, 0o04745,
    0o13005, 0o37140, 0o30155, 0o20237, 0o03461, 0o31662, 0o27146, 0o05547,
    0o02456, 0o30013, 0o00322, 0o10761, 0o26767, 0o36004, 0o30713, 0o07662,
    0o21610, 0o20134, 0o11262, 0o10706, 0o34143, 0o11051, 0o25460, 0o17665,
    0o32354, 0o21230, 0o20146, 0o11362, 0o37246, 0o16344, 0o15034, 0o25471,
    0o25646, 0o22157, 0o04336, 0o16356, 0o04075, 0o02626, 0o11706, 0o37011,
    0o27041, 0o31024)

B1I_ph_sel = ( # PRN 1 - 63
    (1, 3)    , (1, 4)    , (1, 5)   , (1, 6)    , (1, 8)    , (1, 9)    ,
    (1, 10)   , (1, 11)   , (2, 7)   , (3, 4)    , (3, 5)    , (3, 6)    ,
    (3, 8)    , (3, 9)    , (3, 10)  , (3, 11)   , (4, 5)    , (4, 6)    ,
    (4, 8)    , (4, 9)    , (4, 10)  , (4, 11)   , (5, 6)    , (5, 8)    ,
    (5, 9)    , (5, 10)   , (5, 11)  , (6, 8)    , (6, 9)    , (6, 10)   ,
    (6, 11)   , (8, 9)    , (8, 10)  , (8, 11)   , (9, 10)   , (9, 11)   ,
    (10, 11)  , (1, 2, 7) , (1, 3, 4), (1, 3, 6) , (1, 3, 8) , (1, 3, 10),
    (1, 3, 11), (1, 4, 5) , (1, 4, 9), (1, 5, 6) , (1, 5, 8) , (1, 5, 10),
    (1, 5, 11), (1, 6, 9) , (1, 8, 9), (1, 9, 10), (1, 9, 11), (2, 3, 7) ,
    (2, 5, 7) , (2, 7, 9) , (3, 4, 5), (3, 4, 9) , (3, 5, 6) , (3, 5, 8) ,
    (3, 5, 10), (3, 5, 11), (3, 6, 9))

B1CD_ph_diff = ( # PRN 1 - 63
    2678, 4802,  958,  859, 3843, 2232,  124, 4352, 1816, 1126, 1860, 4800,
    2267,  424, 4192, 4333, 2656, 4148,  243, 1330, 1593, 1470,  882, 3202,
    5095, 2546, 1733, 4795, 4577, 1627, 3638, 2553, 3646, 1087, 1843,  216,
    2245,  726, 1966,  670, 4130,   53, 4830,  182, 2181, 2006, 1080, 2288,
    2027,  271,  915,  497,  139, 3693, 2054, 4342, 3342, 2592, 1007,  310,
    4203,  455, 4318)

B1CD_trunc_pnt = ( # PRN 1 - 63
     699,  694, 7318, 2127,  715, 6682, 7850, 5495, 1162, 7682, 6792, 9973,
    6596, 2092,   19,10151, 6297, 5766, 2359, 7136, 1706, 2128, 6827,  693,
    9729, 1620, 6805,  534,  712, 1929, 5355, 6139, 6339, 1470, 6867, 7851,
    1162, 7659, 1156, 2672, 6043, 2862,  180, 2663, 6940, 1645, 1582,  951,
    6878, 7701, 1823, 2391, 2606,  822, 6403,  239,  442, 6769, 2560, 2502,
    5072, 7268,  341)

B1CP_ph_diff = ( # PRN 1 - 63
     796,  156, 4198, 3941, 1374, 1338, 1833, 2521, 3175,  168, 2715, 4408,
    3160, 2796,  459, 3594, 4813,  586, 1428, 2371, 2285, 3377, 4965, 3779,
    4547, 1646, 1430,  607, 2118, 4709, 1149, 3283, 2473, 1006, 3670, 1817,
     771, 2173,  740, 1433, 2458, 3459, 2155, 1205,  413,  874, 2463, 1106,
    1590, 3873, 4026, 4272, 3556,  128, 1200,  130, 4494, 1871, 3073, 4386,
    4098, 1923, 1176)

B1CP_trunc_pnt = ( # PRN 1 - 63
    7575, 2369, 5688,  539, 2270, 7306, 6457, 6254, 5644, 7119, 1402, 5557,
    5764, 1073, 7001, 5910,10060, 2710, 1546, 6887, 1883, 5613, 5062, 1038,
   10170, 6484, 1718, 2535, 1158,  526, 7331, 5844, 6423, 6968, 1280, 1838,
    1989, 6468, 2091, 1581, 1453, 6252, 7122, 7711, 7216, 2113, 1095, 1628,
    1713, 6102, 6123, 6070, 1115, 8047, 6795, 2575,   53, 1729, 6388,  682,
    5565, 7160, 2277)

B1CS_ph_diff = ( # PRN 1 - 63
     269, 1448, 1028, 1324,  822,    5,  155,  458,  310,  959, 1238, 1180,
    1288,  334,  885, 1362,  181, 1648,  838,  313,  750,  225, 1477,  309,
     108, 1457,  149,  322,  271,  576, 1103,  450,  399,  241, 1045,  164,
     513,  687,  422,  303,  324,  495,  725,  780,  367,  882,  631,   37,
     647, 1043,   24,  120,  134,  136,  158,  214,  335,  340,  661,  889,
     929, 1002, 1149)

B1CS_trunc_pnt = ( # PRN 1 - 63
    1889, 1268, 1593, 1186, 1239, 1930,  176, 1696,   26, 1344, 1271, 1182,
    1381, 1604, 1333, 1185,   31,  704, 1190, 1646, 1385,  113,  860, 1656,
    1921, 1173, 1928,   57,  150, 1214, 1148, 1458, 1519, 1635, 1257, 1687,
    1382, 1514,    1, 1583, 1806, 1664, 1338, 1111, 1706, 1543, 1813,  228,
    2871, 2884, 1823,   75,   11,   63, 1937,   22, 1768, 1526, 1402, 1445,
    1680, 1290, 1245)

B2AD_G2_init = ( # PRN 1 - 63
    0b1000000100101, 0b1000000110100, 0b1000010101101, 0b1000101001111,
    0b1000101010101, 0b1000110101110, 0b1000111101110, 0b1000111111011,
    0b1001100101001, 0b1001111011010, 0b1010000110101, 0b1010001000100,
    0b1010001010101, 0b1010001011011, 0b1010001011100, 0b1010010100011,
    0b1010011110111, 0b1010100000001, 0b1010100111110, 0b1010110101011,
    0b1010110110001, 0b1011001010011, 0b1011001100010, 0b1011010011000,
    0b1011010110110, 0b1011011110010, 0b1011011111111, 0b1011100010010,
    0b1011100111100, 0b1011110100001, 0b1011111001000, 0b1011111010100,
    0b1011111101011, 0b1011111110011, 0b1100001010001, 0b1100010010100,
    0b1100010110111, 0b1100100010001, 0b1100100011001, 0b1100110101011,
    0b1100110110001, 0b1100111010010, 0b1101001010101, 0b1101001110100,
    0b1101011001011, 0b1101101010111, 0b1110000110100, 0b1110010000011,
    0b1110010001011, 0b1110010100011, 0b1110010101000, 0b1110100111011,
    0b1110110010111, 0b1111001001000, 0b1111010010100, 0b1111010011001,
    0b1111011011010, 0b1111011111000, 0b1111011111111, 0b1111110110101,
    0b0010000000010, 0b1101111110101, 0b0001111010010)

B2AP_G2_init = ( # PRN 1 - 63
    0b1000000100101, 0b1000000110100, 0b1000010101101, 0b1000101001111,
    0b1000101010101, 0b1000110101110, 0b1000111101110, 0b1000111111011,
    0b1001100101001, 0b1001111011010, 0b1010000110101, 0b1010001000100,
    0b1010001010101, 0b1010001011011, 0b1010001011100, 0b1010010100011,
    0b1010011110111, 0b1010100000001, 0b1010100111110, 0b1010110101011,
    0b1010110110001, 0b1011001010011, 0b1011001100010, 0b1011010011000,
    0b1011010110110, 0b1011011110010, 0b1011011111111, 0b1011100010010,
    0b1011100111100, 0b1011110100001, 0b1011111001000, 0b1011111010100,
    0b1011111101011, 0b1011111110011, 0b1100001010001, 0b1100010010100,
    0b1100010110111, 0b1100100010001, 0b1100100011001, 0b1100110101011,
    0b1100110110001, 0b1100111010010, 0b1101001010101, 0b1101001110100,
    0b1101011001011, 0b1101101010111, 0b1110000110100, 0b1110010000011,
    0b1110010001011, 0b1110010100011, 0b1110010101000, 0b1110100111011,
    0b1110110010111, 0b1111001001000, 0b1111010010100, 0b1111010011001,
    0b1111011011010, 0b1111011111000, 0b1111011111111, 0b1111110110101,
    0b1010010000110, 0b0010111111000, 0b0001101010101)

B2AS_ph_diff = ( # PRN 1 - 63
     123,   55,   40,  139,   31,  175,  350,  450,  478,    8,   73,   97,
     213,  407,  476,    4,   15,   47,  163,  280,  322,  353,  375,  510,
     332,    7,   13,   16,   18,   25,   50,   81,  118,  127,  132,  134,
     164,  177,  208,  249,  276,  349,  439,  477,  498,   88,  155,  330,
       3,   21,   84,  111,  128,  153,  197,  199,  214,  256,  265,  291,
     324,  326,  340)

B2AS_trunc_pnt = ( # PRN 1 - 63
     138,  570,  351,   77,  885,  247,  413,  180,    3,   26,   17,  172,
      30, 1008,  646,  158,  170,   99,   53,  179,  925,  114,   10,  584,
      60,    3,  684,  263,  545,   22,  546,  190,  303,  234,   38,  822,
      57,  668,  697,   93,   18,   66,  318,  133,   98,   70,  132,   26,
     354,   58,   41,  182,  944,  205,   23,    1,  792,  641,   83,    7,
     111,   96,   92)

B2BI_G2_init = ( # PRN 1 - 63
    0b1000000100101, 0b1000000110100, 0b1000010101101, 0b1000101001111,
    0b1000101010101, 0b1000110101110, 0b1000111101110, 0b1000111111011,
    0b1001100101001, 0b1001111011010, 0b1010000110101, 0b1010001000100,
    0b1010001010101, 0b1010001011011, 0b1010001011100, 0b1010010100011,
    0b1010011110111, 0b1010100000001, 0b1010100111110, 0b1010110101011,
    0b1010110110001, 0b1011001010011, 0b1011001100010, 0b1011010011000,
    0b1011010110110, 0b1011011110010, 0b1011011111111, 0b1011100010010,
    0b1011100111100, 0b1011110100001, 0b1011111001000, 0b1011111010100,
    0b1011111101011, 0b1011111110011, 0b1100001010001, 0b1100010010100,
    0b1100010110111, 0b1100100010001, 0b1100100011001, 0b1100110101011,
    0b1100110110001, 0b1100111010010, 0b1101001010101, 0b1101001110100,
    0b1101011001011, 0b1101101010111, 0b1110000110100, 0b1110010000011,
    0b1110010001011, 0b1110010100011, 0b1110010101000, 0b1110100111011,
    0b1110110010111, 0b1111001001000, 0b1111010010100, 0b1111010011001,
    0b1111011011010, 0b1111011111000, 0b1111011111111, 0b1111110110101,
    0b1111110111101, 0b0101110000101, 0b0101100111011)

B3I_G2_init = ( # PRN 1 - 63
    0b1010111111111, 0b1111000101011, 0b1011110001010, 0b1111111111011,
    0b1100100011111, 0b1001001100100, 0b1111111010010, 0b1110111111101,
    0b1010000000010, 0b0010000011011, 0b1110101110000, 0b0010110011110,
    0b0110010010101, 0b0111000100110, 0b1000110001001, 0b1110001111100,
    0b0010011000101, 0b0000011101100, 0b1000101010111, 0b0001011011110,
    0b0010000101101, 0b0010110001010, 0b0001011001111, 0b0011001100010,
    0b0011101001000, 0b0100100101001, 0b1011011010011, 0b1010111100010,
    0b0001011110101, 0b0111111111111, 0b0110110001111, 0b1010110001001,
    0b1001010101011, 0b1100110100101, 0b1101001011101, 0b1111101110100,
    0b0010101100111, 0b1110100010000, 0b1101110010000, 0b1101011001110,
    0b1000000110100, 0b0101111011001, 0b0110110111100, 0b1101001110001,
    0b0011100100010, 0b0101011000101, 0b1001111100110, 0b1111101001000,
    0b0000101001001, 0b1000010101100, 0b1111001001100, 0b0100110001111,
    0b0000000011000, 0b1000000000100, 0b0011010100110, 0b1011001000110,
    0b0111001111000, 0b0010111001010, 0b1100111110110, 0b1001001000101,
    0b0111000100000, 0b0011001000010, 0b0010001001110)

I5S_G2_init = ( # PRN 1 - 14
    0b1110100111, 0b0000100110, 0b1000110100, 0b0101110010, 0b1110110000,
    0b0001101011, 0b0000010100, 0b0100110000, 0b0010011000, 0b1101100100,
    0b0001001100, 0b1101111100, 0b1011010010, 0b0111101010)

ISS_G2_init = ( # PRN 1 - 14
    0b0011101111, 0b0101111101, 0b1000110001, 0b0010101011, 0b1010010001,
    0b0100101100, 0b0010001110, 0b0100100110, 0b1100001110, 0b1010111110,
    0b1110010001, 0b1101101001, 0b0101000101, 0b0100001101)

I1SD_R0_init = ( # PRN 1 - 14
    0o0061727026503255544, 0o1660130752435362260, 0o0676457016477551225,
    0o1763467705267605701, 0o1614265052776007236, 0o1446113457553463523,
    0o1467417471470124574, 0o0022513456555401603, 0o0004420115402210365,
    0o0072276243316574510, 0o1632356715721616750, 0o1670164755420300763,
    0o1752127524253360255, 0o0262220014044243135)

I1SD_R1_init = ( # PRN 1 - 14
    0o0377627103341647600, 0o0047555332635133703, 0o0570574070736102152,
    0o0511013576745450615, 0o1216243446624447775, 0o0176452272675511054,
    0o0151055342317137706, 0o1127720116046071664, 0o0514407436155575524,
    0o0253070462740453542, 0o0573371306324706336, 0o1315135317732077306,
    0o1170303027726635012, 0o1637171270537414673)

I1SD_C_init = ( # PRN 1 - 14
    0b10100, 0b10100, 0b00110, 0b10100, 0b10100, 0b00110, 0b10100, 0b00110,
    0b00110, 0b00110, 0b10100, 0b00110, 0b10100, 0b00110)

I1SP_R0_init = ( # PRN 1 - 14
    0o0227743641272102303, 0o0603070242564637717, 0o0746325144437416120,
    0o0023763714573206044, 0o0155575663373106723, 0o0022277536552741033,
    0o0137757627072411730, 0o0413034001670700216, 0o0501123675324707024,
    0o0013727517464264567, 0o0663351450332761127, 0o1450710073416110356,
    0o1716542347100366110, 0o0743601273016301212)

I1SP_R1_init = ( # PRN 1 - 14
    0o1667217344450257245, 0o0300642746017221737, 0o0474006332201753645,
    0o0613606702460402137, 0o1465531713404064713, 0o1063646422557130427,
    0o1066060465055002004, 0o0225574416605070652, 0o1733560674073230405,
    0o1116277147142260461, 0o0152604753526345370, 0o1110300535412261305,
    0o1046105227571557243, 0o1020346561064461527)

I1SP_C_init = ( # PRN 1 - 14
    0b01000, 0b00000, 0b01000, 0b00000, 0b01000, 0b01000, 0b00000, 0b01000,
    0b00000, 0b00000, 0b00000, 0b01000, 0b01000, 0b00000)

I1SPO_R0_init = ( # PRN 1 - 14
    0b0110111011, 0b0111101000, 0b1100000001, 0b0110110110, 0b0100011000,
    0b0011111100, 0b0001100101, 0b1111000101, 0b0011001100, 0b1000011010,
    0b0001001001, 0b0110101011, 0b0101110000, 0b0010110011)

I1SPO_R1_init = ( # PRN 1 - 14
    0b0100110000, 0b0110000010, 0b1110010001, 0b0101110011, 0b1011000110,
    0b1010101111, 0b1110001000, 0b0001010000, 0b1011111100, 0b0100010101,
    0b1100000100, 0b0111011110, 0b1001110011, 0b1001101010)

NH10 = ( # 10 bits Neuman-Hoffman code
    -1, -1, -1, -1, 1, 1, -1, 1, -1, 1)
 
NH20 = ( # 20 bits Neuman-Hoffman code
   -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1)

BC = ( # Baker code
   -1, -1, -1, 1, -1)

MC = ( # Manchester code
   -1, 1)

G2OCP_OC2 = ( # GLONASS L2OCP OC2
   -1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, -1, -1, -1,
   -1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, -1,
   -1, 1, -1, -1, -1, 1, -1)

BOC = (-1, 1) # BOC(k,k) sub-carrier

#-------------------------------------------------------------------------------
#  Generate primary code.
#
#  args:
#      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
#      prn      (I) PRN number
#
#  returns:
#      code     Primary code as int8 ndarray (-1 or 1)
#               (sub-carrier modulated for BOC or zero-padded for TDM)
#
def gen_code(sig, prn):
    sig = sig.upper()
    if sig == 'L1CA':
        return gen_code_L1CA(prn)
    elif sig == 'L1S':
        return gen_code_L1S(prn)
    elif sig == 'L1CB':
        return gen_code_L1CB(prn)
    elif sig == 'L1CP':
        return gen_code_L1CP(prn)
    elif sig == 'L1CD':
        return gen_code_L1CD(prn)
    elif sig == 'L2CM':
        return gen_code_L2CM(prn)
    elif sig == 'L2CL':
        return gen_code_L2CL(prn)
    elif sig == 'L5I':
        return gen_code_L5I(prn)
    elif sig == 'L5Q':
        return gen_code_L5Q(prn)
    elif sig == 'L5SI':
        return gen_code_L5SI(prn)
    elif sig == 'L5SIV':
        return gen_code_L5SIV(prn)
    elif sig == 'L5SQ':
        return gen_code_L5SQ(prn)
    elif sig == 'L5SQV':
        return gen_code_L5SQV(prn)
    elif sig == 'L6D':
        return gen_code_L6D(prn)
    elif sig == 'L6E':
        return gen_code_L6E(prn)
    elif sig == 'G1CA':
        return gen_code_G1CA(prn)
    elif sig == 'G2CA':
        return gen_code_G2CA(prn)
    elif sig == 'G1OCD':
        return gen_code_G1OCD(prn)
    elif sig == 'G1OCP':
        return gen_code_G1OCP(prn)
    elif sig == 'G2OCP':
        return gen_code_G2OCP(prn)
    elif sig == 'G3OCD':
        return gen_code_G3OCD(prn)
    elif sig == 'G3OCP':
        return gen_code_G3OCP(prn)
    elif sig == 'E1B':
        return gen_code_E1B(prn)
    elif sig == 'E1C':
        return gen_code_E1C(prn)
    elif sig == 'E5AI':
        return gen_code_E5AI(prn)
    elif sig == 'E5AQ':
        return gen_code_E5AQ(prn)
    elif sig == 'E5BI':
        return gen_code_E5BI(prn)
    elif sig == 'E5BQ':
        return gen_code_E5BQ(prn)
    elif sig == 'E6B':
        return gen_code_E6B(prn)
    elif sig == 'E6C':
        return gen_code_E6C(prn)
    elif sig == 'B1I':
        return gen_code_B1I(prn)
    elif sig == 'B1CD':
        return gen_code_B1CD(prn)
    elif sig == 'B1CP':
        return gen_code_B1CP(prn)
    elif sig == 'B2I':
        return gen_code_B2I(prn)
    elif sig == 'B2AD':
        return gen_code_B2AD(prn)
    elif sig == 'B2AP':
        return gen_code_B2AP(prn)
    elif sig == 'B2BI':
        return gen_code_B2BI(prn)
    elif sig == 'B3I':
        return gen_code_B3I(prn)
    elif sig == 'I1SD':
        return gen_code_I1SD(prn)
    elif sig == 'I1SP':
        return gen_code_I1SP(prn)
    elif sig == 'I5S':
        return gen_code_I5S(prn)
    elif sig == 'ISS':
        return gen_code_ISS(prn)
    else:
        return NONE

#-------------------------------------------------------------------------------
#  Generate secondary (overlay) code.
#
#  args:
#      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
#      prn      (I) PRN number
#
#  returns:
#      code     Secondary code as int8 ndarray (-1 or 1)
#
def sec_code(sig, prn):
    sig = sig.upper()
    if sig in ('L1CA', 'L1S', 'L1CB','L1CD', 'L2CM', 'L2CL', 'L6D', 'L6E',
       'G1OCP', 'E1B', 'E6B', 'B1CD', 'B2BI', 'I1SD', 'I5S', 'ISS'):
        return np.array([1], dtype='int8') # no secondary code
    elif sig == 'L1CP':
        return sec_code_L1CP(prn)
    elif sig == 'L5I':
        if prn >= 120 and prn <= 158:
            return sec_code_L5I_SBAS(prn)
        else:
            return sec_code_L5I(prn)
    elif sig == 'L5Q':
        if prn >= 120 and prn <= 158:
            return sec_code_L5Q_SBAS(prn)
        else:
            return sec_code_L5Q(prn)
    elif sig == 'L5SI':
        return sec_code_L5SI(prn)
    elif sig == 'L5SIV':
        return sec_code_L5SIV(prn)
    elif sig == 'L5SQ':
        return sec_code_L5SQ(prn)
    elif sig == 'L5SQV':
        return sec_code_L5SQV(prn)
    elif sig == 'G1CA':
        return sec_code_G1CA(prn)
    elif sig == 'G2CA':
        return sec_code_G2CA(prn)
    elif sig == 'G1OCD':
        return sec_code_G1OCD(prn)
    elif sig == 'G2OCP':
        return sec_code_G2OCP(prn)
    elif sig == 'G3OCD':
        return sec_code_G3OCD(prn)
    elif sig == 'G3OCP':
        return sec_code_G3OCP(prn)
    elif sig == 'E1C':
        return sec_code_E1C(prn)
    elif sig == 'E5AI':
        return sec_code_E5AI(prn)
    elif sig == 'E5AQ':
        return sec_code_E5AQ(prn)
    elif sig == 'E5BI':
        return sec_code_E5BI(prn)
    elif sig == 'E5BQ':
        return sec_code_E5BQ(prn)
    elif sig == 'E6C':
        return sec_code_E6C(prn)
    elif sig == 'B1I':
        return sec_code_B1I(prn)
    elif sig == 'B1CP':
        return sec_code_B1CP(prn)
    elif sig == 'B2I':
        return sec_code_B2I(prn)
    elif sig == 'B2AD':
        return sec_code_B2AD(prn)
    elif sig == 'B2AP':
        return sec_code_B2AP(prn)
    elif sig == 'B3I':
        return sec_code_B3I(prn)
    elif sig == 'I1SP':
        return sec_code_I1SP(prn)
    else:
        return NONE

#-------------------------------------------------------------------------------
#  Generate resampled and zero-padded code.
#
#  args:
#      code     (I) Code as int8 ndarray (-1 or 1)
#      T        (I) Code cycle (period) (s)
#      coff     (I) Code offset (s)
#      fs       (I) Sampling frequency (Hz)
#      N        (I) Number of samples
#      Nz=0     (I) Number of zero-padding (optional)
#
#  returns:
#      code     Resampled and zero-padded code as complex64 ndarray (-1 or 1)
#
def res_code(code, T, coff, fs, N, Nz=0):
    dx = len(code) / T / fs
    ix = ((coff * fs + np.arange(N)) * dx).astype('int')
    code = np.array(code[ix % len(code)], dtype='complex64')
    if Nz > 0:
        code = np.hstack([code, np.zeros(Nz, dtype='complex64')])
    return code

#-------------------------------------------------------------------------------
#  Generate resampled and zero-padded code FFT (DFT).
#
#  args:
#      code     (I) Code as int8 ndarray (-1 or 1)
#      T        (I) Code cycle (period) (s)
#      coff     (I) Code offset (s)
#      fs       (I) Sampling frequency (Hz)
#      N        (I) Number of samples
#      Nz=0     (I) Number of zero-padding (optional)
#
#  returns:
#      code_fft Resampled and zero-padded code DFT as complex64 ndarray
#
def gen_code_fft(code, T, coff, fs, N, Nz=0):
    code_res = res_code(code, T, coff, fs, N, Nz)
    return np.conj(fft.fft(code_res))

#-------------------------------------------------------------------------------
#  Get primary code cycle (period).
#
#  args:
#      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
#
#  returns:
#      cyc      Primary code cycle (period) (s) (0.0: error)
#
def code_cyc(sig):
    sig = sig.upper()
    if sig in ('L1CA', 'L1CB', 'L1S', 'L5I', 'L5Q', 'L5SI', 'L5SIV', 'L5SQ',
       'L5SQV', 'G1CA', 'G2CA', 'G3OCD', 'G3OCP', 'E5AI', 'E5AQ', 'E5BI',
       'E5BQ', 'E6B', 'E6C', 'B1I', 'B2I', 'B2AD', 'B2AP', 'B2BI', 'B3I', 'I5S',
       'ISS'):
        return 1e-3
    elif sig == 'G1OCD':
        return 2e-3
    elif sig in ('L6D', 'L6E', 'E1B', 'E1C'):
        return 4e-3
    elif sig == 'G1OCP':
        return 8e-3
    elif sig in ('L1CP', 'L1CD', 'B1CD', 'B1CP', 'I1SD', 'I1SP'):
        return 10e-3
    elif sig in ('L2CM', 'G2OCP'):
        return 20e-3
    elif sig == 'L2CL':
        return 1500e-3
    else:
        return 0.0

#-------------------------------------------------------------------------------
#  Get primary code length.
#
#  args:
#      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
#
#  returns:
#      N        Primary code length (chips) (0: error)
#
def code_len(sig):
    sig = sig.upper()
    if sig in ('L1CA', 'L1S', 'L1CB', 'G1OCD', 'I5S', 'ISS'):
        return 1023
    elif sig in ('L1CP', 'L1CD', 'L2CM', 'L5I', 'L5Q', 'L5SI', 'L5SIV', 'L5SQ',
        'L5SQV', 'L6D', 'L6E', 'G2OCP', 'G3OCD', 'G3OCP', 'E5AI', 'E5AQ', 'E5BI',
        'E5BQ', 'B1CD', 'B1CP', 'B2AD', 'B2AP', 'B2BI', 'B3I', 'I1SD', 'I1SP'):
        return 10230
    elif sig == 'L2CL':
        return 767250
    elif sig in ('E6B', 'E6C'):
        return 5115
    elif sig in ('E1B', 'E1C', 'G1OCP'):
        return 4092
    elif sig in ('G1CA', 'G2CA'):
        return 511
    elif sig in ('B1I', 'B2I'):
        return 2046
    else:
        return 0

#-------------------------------------------------------------------------------
#  Get signal carrier frequency.
#
#  args:
#      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
#
#  returns:
#      freq     Signal carrier frequency (Hz) (0.0: error)
#
def sig_freq(sig):
    sig = sig.upper()
    if sig in ('L1CA', 'L1CB', 'L1S' , 'E1B', 'E1C', 'L1CP', 'L1CD', 'B1CD',
       'B1CP', 'I1SD', 'I1SP'):
        return 1575.42e6
    elif sig in ('L2CM', 'L2CL'):
        return 1227.60e6
    elif sig in ('L5I', 'L5Q', 'L5SI', 'L5SIV', 'L5SQ', 'L5SQV', 'E5AI', 'E5AQ',
        'B2AD', 'B2AP', 'I5S'):
        return 1176.45e6
    elif sig in ('E5BI', 'E5BQ', 'B2I', 'B2BI'):
        return 1207.14e6
    elif sig in ('L6D', 'L6E', 'E6B' , 'E6C'):
        return 1278.75e6
    elif sig == 'B1I':
        return 1561.098e6
    elif sig == 'B3I':
        return 1268.52e6
    elif sig == 'G1CA':
        return 1602.0e6
    elif sig in ('G1OCD', 'G1OCP'):
        return 1600.995e6
    elif sig == 'G2CA':
        return 1246.0e6
    elif sig == 'G2OCP':
        return 1248.0e6
    elif sig in ('G3OCD', 'G3OCP'):
        return 1202.025e6
    elif sig == 'ISS':
        return 2492.028e6
    else:
        return 0.0

#------------------------------------------------------------------------------
#  Get satellite ID.
#
#  args:
#      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
#      prn      (I) PRN number
#
#  returns:
#      sat      Satellite ID ('???': unknown)
#
def sat_id(sig, prn):
    if sig[0] == 'L':
        if prn >= 1 and prn <= 63: # GPS
            sat = 'G%02d' % (prn)
        elif prn >= 120 and prn <= 158: # SBAS
            sat = 'S%02d' % (prn - 100)
        else: # QZSS
            sat = sat_id_qzss(sig, prn)
    elif sig == 'G1CA' or sig == 'G2CA':
        sat = 'R%c%d' % ('-' if prn < 0 else '+', -prn if prn < 0 else prn)
    elif sig[0] == 'G':
        sat = 'R%02d' % (prn)
    elif sig[0] == 'E':
        sat = 'E%02d' % (prn)
    elif sig[0] == 'B':
        sat = 'C%02d' % (prn)
    elif sig[0] == 'I':
        sat = 'I%02d' % (prn)
    else:
        sat = '???'
    return sat

# get satellite ID for QZSS ([3],[4],[15]) -------------------------------------
def sat_id_qzss(sig, prn):
    sat_L1B = (4, 5, 8, 9)
    sat_L5S = (2, 4, 5, 0, 0, 3, 0, 0, 0, 0, 0, 7, 8)
    
    if sig == 'L1CB' and prn >= 203 and prn <= 206:
        sat = 'J%02d' % (sat_L1B[prn-203])
    elif (sig == 'L1CA' or sig == 'L1CD' or sig == 'L1CP' or sig == 'L2CM'
        or sig == 'L5I' or sig == 'L5Q' or sig == 'L6D') and \
        prn >= 193 and prn <= 202:
        sat = 'J%02d' % (prn - 192)
    elif sig == 'L1S' and prn >= 183 and prn <= 191:
        sat = 'J%02d' % (prn - 182)
    elif sig[:3] == 'L5S' and prn >= 184 and prn <= 206 and sat_L5S[prn-184]:
        sat = 'J%02d' % (sat_L5S[prn-184])
    elif sig == 'L6E' and prn >= 203 and prn <= 212:
        sat = 'J%02d' % (prn - 202)
    else:
        sat = '???'
    return sat

# generate L1C/A code ([1]) ----------------------------------------------------
def gen_code_L1CA(prn):
    if prn < 1 or prn > 210:
        return NONE
    N = 1023
    if prn not in L1CA:
        global L1CA_G1, L1CA_G2
        if len(L1CA_G1) == 0:
            L1CA_G1 = gen_code_L1CA_G1(N)
            L1CA_G2 = gen_code_L1CA_G2(N)
        L1CA[prn] = -L1CA_G1 * np.roll(L1CA_G2, L1CA_G2_delay[prn-1])
    return L1CA[prn]

# generate L1C/A G1 code -------------------------------------------------------
def gen_code_L1CA_G1(N):
    return LFSR(N, 0b1111111111, 0b0010000001, 10)

# generate L1C/A G2 code -------------------------------------------------------
def gen_code_L1CA_G2(N):
    return LFSR(N, 0b1111111111, 0b0110010111, 10)

# generate L1S code ([3]) ------------------------------------------------------
def gen_code_L1S(prn):
    if prn < 184 or prn > 191:
        return NONE
    return gen_code_L1CA(prn)

# generate L1C/B code ([3]) ----------------------------------------------------
def gen_code_L1CB(prn):
    if prn < 203 or prn > 206:
        return NONE
    code = gen_code_L1CA(prn)
    return mod_code(code, BOC) # BOC(1,1)

# generate L1CP code -----------------------------------------------------------
def gen_code_L1CP(prn):
    if prn < 1 or prn > 210:
        return NONE
    N = 10230
    if prn not in L1CP:
        code = gen_code_L1CPD(N, L1CP_weil_idx[prn-1], L1CP_ins_idx[prn-1])
        L1CP[prn] = mod_code(code, BOC) # BOC(1,1) instead of TMBOC(6,1,4/33)
    return L1CP[prn]

# generate L1CD code -----------------------------------------------------------
def gen_code_L1CD(prn):
    if prn < 1 or prn > 210:
        return NONE
    N = 10230
    if prn not in L1CD:
        code = gen_code_L1CPD(N, L1CD_weil_idx[prn-1], L1CD_ins_idx[prn-1])
        L1CD[prn] = mod_code(code, BOC) # BOC(1,1)
    return L1CD[prn]

# generate L1CP/D code ([7]) ---------------------------------------------------
def gen_code_L1CPD(N, w, p):
    global L1C_L_SEQ
    if len(L1C_L_SEQ) == 0:
        L1C_L_SEQ = gen_legendre_seq(10223)
    ins_code = [-1, 1, 1, -1, 1, -1, -1]
    code = np.zeros(N, dtype='int8')
    for t in range(0, p - 1):
        code[t] = -L1C_L_SEQ[t] * L1C_L_SEQ[(t + w) % 10223]
    for t in range(p - 1, p + 6):
        code[t] = ins_code[t - p + 1]
    for t in range(p + 6, N):
        code[t] = -L1C_L_SEQ[t - 7] * L1C_L_SEQ[(t - 7 + w) % 10223]
    return code

# generate Legendre sequence ---------------------------------------------------
def gen_legendre_seq(N):
    L = np.full(N, -1, dtype='int8')
    for i in range(1, N):
        L[(i * i) % N] = 1
    return L

# generate L1CP secondary code ([7]) -------------------------------------------
def sec_code_L1CP(prn):
    if prn < 1 or prn > 210:
        return NONE
    N = 1800
    if prn not in L1CO:
        tap1 = rev_reg(L1CO_S1_poly[prn-1] >> 1, 11)
        code1 = LFSR(N, rev_reg(L1CO_S1_init[prn-1], 11), tap1, 11)
        if prn >= 64:
            tap2 = 0b00000000101
            code2 = LFSR(N, rev_reg(L1CO_S2_init[prn-64], 11), tap2, 11)
            code1 = -code1 * code2
        L1CO[prn] = code1
    return L1CO[prn]

# generate L2CM code ([1]) -----------------------------------------------------
def gen_code_L2CM(prn):
    if (prn < 1 or prn > 63) and (prn < 159 or prn > 210):
        return NONE
    N = 10230
    if prn not in L2CM:
        R = L2CM_R_init_1[prn-1] if prn <= 63 else L2CM_R_init_2[prn-159]
        code = gen_code_L2C(N, R)
        L2CM[prn] = mod_code(code, [-1, 0]) # TDM
    return L2CM[prn]

# generate L2CL code ([1]) -----------------------------------------------------
def gen_code_L2CL(prn):
    if (prn < 1 or prn > 63) and (prn < 159 or prn > 210):
        return NONE
    N = 767250
    if prn not in L2CL:
        R = L2CL_R_init_1[prn-1] if prn <= 63 else L2CL_R_init_2[prn-159]
        code = gen_code_L2C(N, R)
        L2CL[prn] = mod_code(code, [0, 1]) # TDM
    return L2CL[prn]

# generate L2C code ([1]) ------------------------------------------------------
def gen_code_L2C(N, R):
    code = np.zeros(N, dtype='int8')
    for i in range(N):
        code[i] = CHIP[R & 1]
        R = (R >> 1) ^ (0b100100101001001010100111100 * (R & 1))
    return code

# generate L5I code ([2]) ------------------------------------------------------
def gen_code_L5I(prn):
    if prn < 1 and prn > 210:
        return NONE
    N = 10230
    if prn not in L5I:
        global L5_XA, L5_XB
        if len(L5_XA) == 0:
            L5_XA = gen_code_L5_XA(N)
            L5_XB = gen_code_L5_XB(N)
        L5I[prn] = -L5_XA * np.roll(L5_XB, -L5I_XB_adv[prn-1])
    return L5I[prn]

# generate L5Q code ([2]) ------------------------------------------------------
def gen_code_L5Q(prn):
    if prn < 1 and prn > 210:
        return NONE
    N = 10230
    if prn not in L5Q:
        global L5_XA, L5_XB
        if len(L5_XA) == 0:
            L5_XA = gen_code_L5_XA(N)
            L5_XB = gen_code_L5_XB(N)
        L5Q[prn] = -L5_XA * np.roll(L5_XB, -L5Q_XB_adv[prn-1])
    return L5Q[prn]

# generate L5SI code ([15]) ----------------------------------------------------
def gen_code_L5SI(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return gen_code_L5I(prn)

# generate L5SIV code ([15]) ---------------------------------------------------
def gen_code_L5SIV(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return gen_code_L5I(prn)

# generate L5SQ code ([15]) ----------------------------------------------------
def gen_code_L5SQ(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return gen_code_L5Q(prn)

# generate L5SQV code ([15]) ---------------------------------------------------
def gen_code_L5SQV(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return gen_code_L5Q(prn)

# generate L5 XA code ----------------------------------------------------------
def gen_code_L5_XA(N):
    code = LFSR(8190, 0b1111111111111, 0b0000000011011, 13)

# generate L5SQ code ([15]) ----------------------------------------------------
def gen_code_L5SQ(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return gen_code_L5Q(prn)

# generate L5 XA code ----------------------------------------------------------
def gen_code_L5_XA(N):
    code = LFSR(8190, 0b1111111111111, 0b0000000011011, 13)
    return np.hstack([code, code[:N-8190]])

# generate L5 XB code ----------------------------------------------------------
def gen_code_L5_XB(N):
    return LFSR(N, 0b1111111111111, 0b1011011100011, 13)

# generate L5I secondary code ([2]) --------------------------------------------
def sec_code_L5I(prn):
    return np.array(NH10, dtype='int8')

# generate L5I SBAS secondary code ---------------------------------------------
def sec_code_L5I_SBAS(prn):
    return np.array(MC, dtype='int8')

# generate L5Q secondary code ([2]) --------------------------------------------
def sec_code_L5Q(prn):
    return np.array(NH20, dtype='int8')

# generate L5Q SBAS secondary code ---------------------------------------------
def sec_code_L5Q_SBAS(prn):
    return np.array(MC, dtype='int8')

# generate L5SI secondary code ([15]) ------------------------------------------
def sec_code_L5SI(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return np.array([1], dtype='int8') # normal mode

# generate L5SIV secondary code ([15]) -----------------------------------------
def sec_code_L5SIV(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return sec_code_L5I_SBAS(prn) # verification mode

# generate L5SQ secondary code ([15]) ------------------------------------------
def sec_code_L5SQ(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return sec_code_L5Q(prn) # normal mode

# generate L5SQV secondary code ([15]) -----------------------------------------
def sec_code_L5SQV(prn):
    if (prn < 184 or prn > 189) and (prn < 205 or prn > 206):
        return NONE
    return sec_code_L5Q_SBAS(prn) # verification mode

# generate L6D code ([4]) ------------------------------------------------------
def gen_code_L6D(prn):
    if prn < 193 or prn > 202:
        return NONE
    N = 10230
    if prn not in L6D:
        code = gen_code_L6(N, L6D_R_init[prn-193])
        L6D[prn] = mod_code(code, [-1, 0]) # TDM
    return L6D[prn]

# generate L6E code ([4]) ------------------------------------------------------
def gen_code_L6E(prn):
    if prn < 203 or prn > 212:
        return NONE
    N = 10230
    if prn not in L6E:
        code = gen_code_L6(N, L6E_R_init[prn-203])
        L6E[prn] = mod_code(code, [0, -1]) # TDM
    return L6E[prn]

# generate L6 code -------------------------------------------------------------
def gen_code_L6(N, R):
    R = rev_reg(R, 20)
    code1 = LFSR(N, 0b1111111111, 0b0011110011, 10)
    code2 = LFSR(N, R, 0b00000000000001010011, 20)
    return -code1 * code2

# generate GLONASS C/A code ----------------------------------------------------
def gen_code_GLO_CA(N):
    R = 0b111111111
    code = np.zeros(N, dtype='int8')
    for i in range(N):
        code[i] = CHIP[(R >> 2) & 1]
        R = (sdr_func.xor_bits(R & 0b000010001) << 8) | (R >> 1)
    return code

# generate G1CA code ([14]) ----------------------------------------------------
def gen_code_G1CA(prn):
    if prn < -7 or prn > 6: # FCN
        return NONE
    N = 511
    if 1 not in G1CA:
        G1CA[1] = gen_code_GLO_CA(N)
    return G1CA[1]

# generate G2CA code ([14]) ----------------------------------------------------
def gen_code_G2CA(prn):
    return gen_code_G1CA(prn)

# generate G1OCD code ([19]) ---------------------------------------------------
def gen_code_G1OCD(prn):
   if prn < 0 or prn > 63:
       return NONE
   N = 1023
   if prn not in G1OCD:
       DC1 = LFSR(N, 0b0011001000, 0b0000001001, 10)
       DC2 = LFSR(N, prn, 0b0010001011, 10)
       G1OCD[prn] = mod_code(-DC1 * DC2, [-1, 0]) # TDM
   return G1OCD[prn]

# generate G1OCP code ([19]) ---------------------------------------------------
def gen_code_G1OCP(prn):
   if prn < 0 or prn > 63:
       return NONE
   N = 4092
   if prn not in G1OCP:
       DC1 = LFSR(N, 0b000011000101, 0b0001010011, 12)
       DC2 = LFSR(N, prn, 0b100001, 6)
       G1OCP[prn] = mod_code(-DC1 * DC2, [0, 0, -1, 1]) # BOC(1,1) + TDM
   return G1OCP[prn]

# generate G2OCP code ([20]) ---------------------------------------------------
def gen_code_G2OCP(prn):
   if prn < 0 or prn > 63:
       return NONE
   N = 10230
   if prn not in G2OCP:
       DC1 = LFSR(N, 0b00110100111000, 0b00010001000011, 14)
       DC2 = LFSR(N, prn + 64, 0b0000011, 7)
       G2OCP[prn] = mod_code(-DC1 * DC2, [0, 0, -1, 1]) # BOC(1,1) + TDM
   return G2OCP[prn]

# generate G3OCD code ([17]) ---------------------------------------------------
def gen_code_G3OCD(prn):
   if prn < 0 or prn > 63:
       return NONE
   N = 10230
   if prn not in G3OCD:
       DC1 = gen_code_G3OC_DC1(N)
       DC2 = LFSR(N, prn, 0b0000011, 7)
       G3OCD[prn] = -DC1 * DC2
   return G3OCD[prn]

# generate G3OCP code ([17]) ---------------------------------------------------
def gen_code_G3OCP(prn):
   if prn < 0 or prn > 63:
       return NONE
   N = 10230
   if prn not in G3OCP:
       DC1 = gen_code_G3OC_DC1(N)
       DC3 = LFSR(N, prn + 64, 0b0000011, 7)
       G3OCP[prn] = -DC1 * DC3
   return G3OCP[prn]

# generate G3OC DC1 code ([17]) ------------------------------------------------
def gen_code_G3OC_DC1(N):
   global G3OC_D1
   if len(G3OC_D1) == 0:
       G3OC_D1 = LFSR(N, 0b00110100111000, 0b00010001000011, 14)
   return G3OC_D1

# generate G1CA secondary code -------------------------------------------------
def sec_code_G1CA(prn):
    if prn < -7 or prn > 6: # FCN
        return NONE
    if prn % 2 == 0:
        return np.array([1], dtype='int8')
    else:
        return np.array(MC, dtype='int8')

# generate G2CA secondary code -------------------------------------------------
def sec_code_G2CA(prn):
    return sec_code_G1CA(prn)

# generate G1OCD secondary code ([19]) -----------------------------------------
def sec_code_G1OCD(prn):
   if prn < 0 or prn > 63:
       return NONE
   return np.array(MC, dtype='int8')

# generate G2OCP secondary code ([20]) -----------------------------------------
def sec_code_G2OCP(prn):
   if prn < 0 or prn > 63:
       return NONE
   return np.array(G2OCP_OC2, dtype='int8')

# generate G3OCD secondary code ([17]) -----------------------------------------
def sec_code_G3OCD(prn):
   if prn < 0 or prn > 63:
       return NONE
   return np.array(BC, dtype='int8')

# generate G3OCP secondary code ([17]) -----------------------------------------
def sec_code_G3OCP(prn):
   if prn < 0 or prn > 63:
       return NONE
   return np.array(NH10, dtype='int8')

# generate E1B code ([5]) ------------------------------------------------------
def gen_code_E1B(prn):
    if prn < 1 or prn > 50:
        return NONE
    N = 4092
    if prn not in E1B:
        code = read_code_hex(sdr_code_gal.E1B[prn-1], N)
        E1B[prn] = mod_code(code, BOC) # BOC(1,1) instead of CBOC(6,1,1/11)
    return E1B[prn]

# generate E1C code ([5]) ------------------------------------------------------
def gen_code_E1C(prn):
    if prn < 1 or prn > 50:
        return NONE
    N = 4092
    if prn not in E1C:
        code = read_code_hex(sdr_code_gal.E1C[prn-1], N)
        E1C[prn] = mod_code(code, BOC) # BOC(1,1) instead of CBOC(6,1,1/11)
    return E1C[prn]

# generate E1C secondary code ([5]) -------------------------------------------
def sec_code_E1C(prn):
    return read_code_hex(sdr_code_gal.CS25, 25)

# generate E5AI code ([5]) -----------------------------------------------------
def gen_code_E5AI(prn):
    if prn < 1 or prn > 50:
        return NONE
    N = 10230
    if prn not in E5AI:
        code1 = gen_code_E5_X1(N, 0o40503)
        code2 = gen_code_E5_X2(N, 0o50661, E5AI_X2_init[prn-1])
        E5AI[prn] = -code1 * code2
    return E5AI[prn]

# generate E5AI secondary code ([5]) -------------------------------------------
def sec_code_E5AI(prn):
    return read_code_hex(sdr_code_gal.CS20, 20)

# generate E5AQ code ([5]) -----------------------------------------------------
def gen_code_E5AQ(prn):
    if prn < 1 or prn > 50:
        return NONE
    N = 10230
    if prn not in E5AQ:
        code1 = gen_code_E5_X1(N, 0o40503)
        code2 = gen_code_E5_X2(N, 0o50661, E5AQ_X2_init[prn-1])
        E5AQ[prn] = -code1 * code2
    return E5AQ[prn]

# generate E5AQ secondary code ([5]) -------------------------------------------
def sec_code_E5AQ(prn):
    if prn < 1 or prn > 50:
       return NONE
    return read_code_hex(sdr_code_gal.CS100[prn-1], 100)

# generate E5BI code ([5]) -----------------------------------------------------
def gen_code_E5BI(prn):
    if prn < 1 or prn > 50:
        return NONE
    N = 10230
    if prn not in E5BI:
        code1 = gen_code_E5_X1(N, 0o64021)
        code2 = gen_code_E5_X2(N, 0o51445, E5BI_X2_init[prn-1])
        E5BI[prn] = -code1 * code2
    return E5BI[prn]

# generate E5BI secondary code ([5]) -------------------------------------------
def sec_code_E5BI(prn):
    return read_code_hex(sdr_code_gal.CS4, 4)

# generate E5BQ code ([5]) -----------------------------------------------------
def gen_code_E5BQ(prn):
    if prn < 1 or prn > 50:
        return NONE
    N = 10230
    if prn not in E5BQ:
        code1 = gen_code_E5_X1(N, 0o64021)
        code2 = gen_code_E5_X2(N, 0o43143, E5BQ_X2_init[prn-1])
        E5BQ[prn] = -code1 * code2
    return E5BQ[prn]

# generate E5BQ secondary code ([5]) -------------------------------------------
def sec_code_E5BQ(prn):
    if prn < 1 or prn > 50:
       return NONE
    return read_code_hex(sdr_code_gal.CS100[prn+49], 100)

# generate E5 code X1 ----------------------------------------------------------
def gen_code_E5_X1(N, tap):
    return LFSR(N, 0b11111111111111, rev_reg(tap >> 1, 14), 14)

# generate E5 code X2 ----------------------------------------------------------
def gen_code_E5_X2(N, tap, R):
    return LFSR(N, rev_reg(R, 14), rev_reg(tap >> 1, 14), 14)

# generate E6B code ([6]) ------------------------------------------------------
def gen_code_E6B(prn):
    if prn < 1 or prn > 50:
        return NONE
    N = 5115
    if prn not in E6B:
        E6B[prn] = read_code_hex(sdr_code_gal.E6B[prn-1], N)
    return E6B[prn]

# generate E6C code ([6]) ------------------------------------------------------
def gen_code_E6C(prn):
    if prn < 1 or prn > 50:
        return NONE
    N = 5115
    if prn not in E6C:
        E6C[prn] = read_code_hex(sdr_code_gal.E6C[prn-1], N)
    return E6C[prn]

# generate E6C secondary code ([5]) --------------------------------------------
def sec_code_E6C(prn):
    if prn < 1 or prn > 50:
       return NONE
    return read_code_hex(sdr_code_gal.CS100[prn-1], 100)

# generate B1I code ([12]) -----------------------------------------------------
def gen_code_B1I(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 2046
    if prn not in B1I:
        code1 = gen_code_B1I_G1(N)
        code2 = gen_code_B1I_G2(N, B1I_ph_sel[prn-1])
        B1I[prn] = -code1 * code2
    return B1I[prn]

# generate B1I G1 --------------------------------------------------------------
def gen_code_B1I_G1(N):
    return LFSR(N, 0b01010101010, 0b10000011111, 11)

# generate B1I G2 --------------------------------------------------------------
def gen_code_B1I_G2(N, ph_sel):
    tap = 0
    for p in ph_sel:
        tap |= 1 << (11 - p)
    R = 0b01010101010
    code = np.zeros(N, dtype='int8')
    for i in range(N):
        code[i] = CHIP[sdr_func.xor_bits(R & tap)]
        R = (sdr_func.xor_bits(R & 0b11111001101) << 10) | (R >> 1)
    return code

# generate B1I secondary code ([12]) -------------------------------------------
def sec_code_B1I(prn):
    if (prn >= 1 and prn <= 5) or (prn >=59 and prn <= 63): # D2 (GEO)
       return np.array([1], dtype='int8')
    elif prn >= 6 and prn <= 58: # D1 (MEO/IGSO)
       return np.array(NH20, dtype='int8')
    else:
       return NONE

# generate B1CD code ([8]) -----------------------------------------------------
def gen_code_B1CD(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 10230
    if prn not in B1CD:
        code = np.zeros(N, dtype='int8')
        for i in range(N):
            j = (i + B1CD_trunc_pnt[prn-1] - 1) % 10243
            code[i] = B1C_weil_code(j, B1CD_ph_diff[prn-1])
        B1CD[prn] = mod_code(code, BOC) # BOC(1,1)
    return B1CD[prn]

# generate B1CP code ([8]) -----------------------------------------------------
def gen_code_B1CP(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 10230
    if prn not in B1CP:
        code = np.zeros(N, dtype='int8')
        for i in range(N):
            j = (i + B1CP_trunc_pnt[prn-1] - 1) % 10243
            code[i] = B1C_weil_code(j, B1CP_ph_diff[prn-1])
        B1CP[prn] = mod_code(code, BOC) # BOC(1,1) instead of QMBOC(6,1,4/33)
    return B1CP[prn]

# B1C Weil-code 10243 chips ----------------------------------------------------
def B1C_weil_code(k, w):
    global B1C_L_SEQ
    if len(B1C_L_SEQ) == 0:
        B1C_L_SEQ = gen_legendre_seq(10243)
    return -B1C_L_SEQ[k] * B1C_L_SEQ[(k + w) % 10243]

# generate B1CP secondary code ([8]) -------------------------------------------
def sec_code_B1CP(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 1800
    if prn not in B1CS:
        code = np.zeros(N, dtype='int8')
        for i in range(N):
            j = (i + B1CS_trunc_pnt[prn-1] - 1) % 3607
            code[i] = B1C_weil_code_s(j, B1CS_ph_diff[prn-1])
        B1CS[prn] = code
    return B1CS[prn]

# B1C Weil-code 3607 chip ------------------------------------------------------
def B1C_weil_code_s(k, w):
    global B1C_L_SEQ_S
    if len(B1C_L_SEQ_S) == 0:
        B1C_L_SEQ_S = gen_legendre_seq(3607)
    return -B1C_L_SEQ_S[k] * B1C_L_SEQ_S[(k + w) % 3607]

# generate B2I code ------------------------------------------------------------
def gen_code_B2I(prn):
    return gen_code_B1I(prn)

# generate B2I secondary code --------------------------------------------------
def sec_code_B2I(prn):
    return sec_code_B1I(prn)

# generate B2AD code ([9]) -----------------------------------------------------
def gen_code_B2AD(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 10230
    if prn not in B2AD:
        global B2AD_G1
        if len(B2AD_G1) == 0:
            B2AD_G1 = gen_code_B2AD_G1(N)
        B2AD[prn] = -B2AD_G1 * gen_code_B2AD_G2(N, B2AD_G2_init[prn-1])
    return B2AD[prn]

# generate B2AD G1 code --------------------------------------------------------
def gen_code_B2AD_G1(N):
    code = LFSR(8190, 0b1111111111111, 0b1000100000101, 13)
    return np.hstack([code, code[:N-8190]])

# generate B2AD G2 code --------------------------------------------------------
def gen_code_B2AD_G2(N, R):
    return LFSR(N, R, 0b0010100010111, 13)

# generate B2AD secodary code ([9]) --------------------------------------------
def sec_code_B2AD(prn):
    code = (-1, -1, -1, 1, -1)
    return np.array(code, dtype='int8')

# generate B2AP code ([9]) -----------------------------------------------------
def gen_code_B2AP(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 10230
    if prn not in B2AP:
        global B2AP_G1
        if len(B2AP_G1) == 0:
            B2AP_G1 = gen_code_B2AP_G1(N)
        B2AP[prn] = -B2AP_G1 * gen_code_B2AP_G2(N, B2AP_G2_init[prn-1])
    return B2AP[prn]

# generate B2AP G1 code --------------------------------------------------------
def gen_code_B2AP_G1(N):
    code = LFSR(8190, 0b1111111111111, 0b0010011000001, 13)
    return np.hstack([code, code[:N-8190]])

# generate B2AP G2 code --------------------------------------------------------
def gen_code_B2AP_G2(N, R):
    return LFSR(N, R, 0b1000101100011, 13)

# generate B2AP secondary code ([9]) -------------------------------------------
def sec_code_B2AP(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 100
    if prn not in B2AS:
        code = np.zeros(N, dtype='int8')
        for i in range(N):
            j = (i + B2AS_trunc_pnt[prn-1] - 1) % 1021
            code[i] = B2A_weil_code(j, B2AS_ph_diff[prn-1])
        B2AS[prn] = code
    return B2AS[prn]

# B2A Weil-code 1021 chip ------------------------------------------------------
def B2A_weil_code(k, w):
    global B2A_L_SEQ
    if len(B2A_L_SEQ) == 0:
        B2A_L_SEQ = gen_legendre_seq(1021)
    return -B2A_L_SEQ[k] * B2A_L_SEQ[(k + w) % 1021]

# generate B2BI code ([10],[11]) -----------------------------------------------
def gen_code_B2BI(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 10230
    if prn not in B2BI:
        global B2BI_G1
        if len(B2BI_G1) == 0:
            B2BI_G1 = gen_code_B2BI_G1(N)
        B2BI[prn] = -B2BI_G1 * gen_code_B2BI_G2(N, B2BI_G2_init[prn-1])
    return B2BI[prn]

# generate B2BI G1 code --------------------------------------------------------
def gen_code_B2BI_G1(N):
    code = LFSR(8190, 0b1111111111111, 0b1000000011001, 13)
    return np.hstack([code, code[:N-8190]])

# generate B2BI G2 code --------------------------------------------------------
def gen_code_B2BI_G2(N, R):
    return LFSR(N, R, 0b0011010010011, 13)

# generate B3I code ([13]) -----------------------------------------------------
def gen_code_B3I(prn):
    if prn < 1 or prn > 63:
        return NONE
    N = 10230
    if prn not in B3I:
        global B3I_G1
        if len(B3I_G1) == 0:
            B3I_G1 = gen_code_B3I_G1(N)
        B3I[prn] = -B3I_G1 * gen_code_B3I_G2(N, B3I_G2_init[prn-1])
    return B3I[prn]

# generate B3I G1 code ---------------------------------------------------------
def gen_code_B3I_G1(N):
    code = LFSR(8190, 0b1111111111111, 0b1011000000001, 13)
    return np.hstack([code, code[:N-8190]])

# generate B3I G2 code ---------------------------------------------------------
def gen_code_B3I_G2(N, R_init):
    return LFSR(N, R_init, 0b1000111011011, 13)

# generate B3I secondary code --------------------------------------------------
def sec_code_B3I(prn):
    return sec_code_B1I(prn)

# generate I1SD code ([18]) ----------------------------------------------------
def gen_code_I1SD(prn):
    if prn < 1 or prn > 14:
        return NONE
    N = 10230
    global I1SD
    if prn not in I1SD:
        code = np.zeros(N, dtype='int8')
        R0 = I1SD_R0_init[prn-1]
        R1 = I1SD_R1_init[prn-1]
        C = I1SD_C_init[prn-1]
        for i in range(N):
            code[i] = CHIP[((C>>4) ^ (R1>>54)) & 1]
            R0, R1, C = shift_I1S(R0, R1, C)
        #I1SD[prn] = code
        I1SD[prn] = mod_code(code, BOC) # BOC(1,1)
    return I1SD[prn]

# generate I1SP code ([18]) ----------------------------------------------------
def gen_code_I1SP(prn):
    if prn < 1 or prn > 14:
        return NONE
    N = 10230
    global I1SP
    if prn not in I1SP:
        code = np.zeros(N, dtype='int8')
        R0 = I1SP_R0_init[prn-1]
        R1 = I1SP_R1_init[prn-1]
        C = I1SP_C_init[prn-1]
        for i in range(N):
            code[i] = CHIP[((C>>4) ^ (R1>>54)) & 1]
            R0, R1, C = shift_I1S(R0, R1, C)
        #I1SP[prn] = code
        I1SP[prn] = mod_code(code, BOC) # BOC(1,1) instead of CBOC(6,1,1/11)
    return I1SP[prn]

# shift registers of I1S code ([18]) -------------------------------------------
def shift_I1S(R0, R1, C):
    R0A = (R0<<50) ^ (R0<<45) ^ (R0<<40) ^ (R0<<20) ^ (R0<<10) ^ (R0<<5) ^ R0
    S2A = ((R0<<50) ^ (R0<<45) ^ (R0<<40)) & ((R0<<20) ^ (R0<<10) ^ (R0<<5) ^ R0)
    S2B = (((R0<<50) ^ (R0<<45)) & (R0<<40)) ^ (((R0<<20) ^ (R0<<10)) & ((R0<<5) ^ R0))
    S2C = ((R0<<50) & (R0<<45)) ^ ((R0<<20) & (R0<<10)) ^ ((R0<<5) & R0)
    S2 = S2A ^ S2B ^ S2C
    R1A = S2 ^ (R0<<40) ^ (R0<<35) ^ (R0<<30) ^ (R0<<25) ^ (R0<<15) ^ R0
    R1B = (R1<<50) ^ (R1<<45) ^ (R1<<40) ^ (R1<<20) ^ (R1<<10) ^ (R1<<5) ^ R1
    R0 = ((R0<<1) & 0x7FFFFFFFFFFFFF) | ((R0A>>54) & 1)
    R1 = ((R1<<1) & 0x7FFFFFFFFFFFFF) | (((R1A ^ R1B)>>54) & 1)
    C = ((C<<1) & 0x1F) | ((C>>4) & 1)
    return R0, R1, C

# generate I1SP overlay code ([18]) --------------------------------------------
def sec_code_I1SP(prn):
    if prn < 1 or prn > 14:
        return NONE
    N = 1800
    global I1SPO
    if prn not in I1SPO:
        code = np.zeros(N, dtype='int8')
        R0 = I1SPO_R0_init[prn-1]
        R1 = I1SPO_R1_init[prn-1]
        for i in range(N):
            code[i] = CHIP[(R1>>9) & 1]
            R0, R1 = shift_I1SO(R0, R1)
        I1SPO[prn] = code
    return I1SPO[prn]

# shift registers of I1S overlay code ([18]) -----------------------------------
def shift_I1SO(R0, R1):
    R0A = (R0<<5) ^ (R0<<2) ^ (R0<<1) ^ R0
    S2A = ((R0<<5) ^ (R0<<2)) & ((R0<<1) ^ R0)
    S2B = ((R0<<5) & (R0<<2)) ^ ((R0<<1) & R0)
    R1A = S2A ^ S2B ^ (R0<<6) ^ (R0<<3) ^ (R0<<2) ^ R0
    R1B = (R1<<5) ^ (R1<<2) ^ (R1<<1) ^ R1
    R0 = ((R0<<1) & 0x3FF) | ((R0A>>9) & 1)
    R1 = ((R1<<1) & 0x3FF) | (((R1A ^ R1B)>>9) & 1)
    return R0, R1

# generate I5S code ([16]) -----------------------------------------------------
def gen_code_I5S(prn):
    if prn < 1 or prn > 14:
        return NONE
    N = 1023
    global I5S
    if prn not in I5S:
        I5S_G1 = LFSR(N, 0b1111111111, 0b0010000001, 10)
        I5S_G2 = LFSR(N, rev_reg(I5S_G2_init[prn-1], 10), 0b0110010111, 10)
        I5S[prn] = -I5S_G1 * I5S_G2
    return I5S[prn]

# generate ISS code ([16]) -----------------------------------------------------
def gen_code_ISS(prn):
    if prn < 1 or prn > 14:
        return NONE
    N = 1023
    global ISS
    if prn not in ISS:
        ISS_G1 = LFSR(N, 0b1111111111, 0b0010000001, 10)
        ISS_G2 = LFSR(N, rev_reg(ISS_G2_init[prn-1], 10), 0b0110010111, 10)
        ISS[prn] = -ISS_G1 * ISS_G2
    return ISS[prn]

# modulation of code by sub-carrier --------------------------------------------
def mod_code(code, sub_carr):
    ix = np.arange(len(code) * len(sub_carr)) // len(sub_carr)
    return -code[ix] * np.array(sub_carr * len(code), dtype='int8')

# read code HEX strings --------------------------------------------------------
def read_code_hex(str, N):
    code = np.zeros(N, dtype='int8')
    for i in range(N):
        code[i] = CHIP[(int(str[i // 4], 16) >> (3 - i % 4)) & 1]
    return code

# reverse bits in shift register -----------------------------------------------
def rev_reg(R, N):
    RR = 0
    for i in range(N):
        RR = (RR << 1) | ((R >> i) & 1)
    return RR

# generate code by LFSR  -------------------------------------------------------
def LFSR(N, R, tap, n):
    code = np.zeros(N, dtype='int8')
    for i in range(N):
        code[i] = CHIP[R & 1]
        R = (sdr_func.xor_bits(R & tap) << (n - 1)) | (R >> 1)
    return code

