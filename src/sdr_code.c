//
//  Pocket SDR C library - GNSS Spreading Code Functions
// 
//  References:
//  [1] IS-GPS-200K, NAVSTAR GPS Space Segment/Navigation User Segment
//      Interfaces, May 19, 2019
//  [2] IS-GPS-705A, Navstar GPS Space Segment / User Segment L5 Interfaces,
//      June 8, 2010
//  [3] IS-QZSS-PNT-004, Quasi-Zenith Satellite System Interface Specification
//      Satellite Positioning, Navigation and Timing Service, November 5, 2018
//  [4] IS-QZSS-L6-005, Quasi-Zenith Satellite System Interface Specification
//      Centimeter Level Augmentation Service, September 21, 2022
//  [5] Galileo Open Service Signal In Space Interface Control Document -
//      Issue 1, February 2010
//  [6] Galileo E6-B/C Codes Technical Note - Issue 1, January 2019
//  [7] IS-GPS-800F, Navstar GPS Space Segment / User Segment L1C Interfaces,
//      March 4, 2019
//  [8] BeiDou Navigation Satellite System Signal In Space Interface Control
//      Document - Open Service Signal B1C (Version 1.0), December, 2017
//  [9] BeiDou Navigation Satellite System Signal In Space Interface Control
//      Document - Open Service Signal B2a (Version 1.0), December, 2017
//  [10] BeiDou Navigation Satellite System Signal In Space Interface Control
//      Document - Open Service Signal B2b (Version 1.0), July, 2020
//  [11] BeiDou Navigation Satellite System Signal In Space Interface Control
//      Document - Precise Positioning Service Signal PPP-B2b (Version 1.0),
//      July, 2020
//  [12] BeiDou Navigation Satellite System Signal In Space Interface Control
//      Document - Open Service Signal B1I (Version 3.0), February, 2019
//  [13] BeiDou Navigation Satellite System Signal In Space Interface Control
//      Document - Open Service Signal B3I (Version 1.0), February, 2018
//  [14] Global Navigation Satellite System GLONASS Interface Control Document
//      Navigation radiosignal in bands L1, L2 (Version 5.1), 2008
//  [15] IS-QZSS-TV-004, Quasi-Zenith Satellite System Interface Specification
//      Positioning Technology Verification Service, Septemver 27, 2023
//  [16] IRNSS SIS ICD for Standard Positioning Service version 1.1, August,
//      2017
//  [17] GLONASS Interface Control Document Code Division Multiple Access Open
//      Service Navigation Signal in L3 frequency band Edition 1.0, 2016
//  [18] NavIC Signal in Space ICD for Standard Positioning Service in L1
//      Frequency version 1.0, August, 2023
//  [19] GLONASS Interface Control Document Code Division Multiple Access Open
//      Service Navigation Signal in L1 frequency band Edition 1.0, 2016
//  [20] GLONASS Interface Control Document Code Division Multiple Access Open
//      Service Navigation Signal in L2 frequency band Edition 1.0, 2016
//
//  Author:
//  T.TAKASU
// 
//  History:
//  2022-05-17  1.0  port sdr_code.py to C
//  2022-05-18  1.1  change API: *() -> sdr_*()
//  2022-05-23  1.2  add API: sdr_code_cyc()
//  2022-07-08  1.3  fix bug in sdr_sig_freq()
//  2022-07-10  1.4  fix memory-free bug in gen_code_L1CB()
//  2022-08-15  1.6  ensure thread-safety of sdr_gen_code(), sdr_sec_code()
//                   and sdr_gen_code_fft()
//  2023-11-08  1.7  L1S PRN range: 184-191 -> 183-191
//  2023-12-27  1.8  modify API sdr_res_code(): return float *
//                   L5S PRN range: 184-189 -> 184-189,205-206 [15]
//                   add signal L5SIV (L5SI verification mode)
//  2024-01-03  1.9  add secondary code of G1CA with odd FCN
//  2024-01-04  1.10 add signal L5SQV (L5SQ verification mode)
//                   fix L5Q SBAS secondary code
//  2024-01-06  1.11 add signal I1SD, I1SP
//  2024-01-07  1.12 add signal G1OCD, G1OCP, G2OCP
//  2024-01-15  1.13 add API sdr_sat_id()
//
#include <ctype.h>
#include "pocket_sdr.h"

// Galileo code HEX strings in sdr_code_gal.c ---------------------------------
extern const char *code_gal_E1B[];
extern const char *code_gal_E1C[];
extern const char *code_gal_E6B[];
extern const char *code_gal_E6C[];
extern const char *code_gal_CS4;
extern const char *code_gal_CS20;
extern const char *code_gal_CS25;
extern const char *code_gal_CS100[];

// constants ------------------------------------------------------------------
static const int8_t CHIP[] = {-1, 1};

// code caches ----------------------------------------------------------------
static int8_t *L1CA [210] = {0};
static int8_t *L1CP [210] = {0};
static int8_t *L1CD [210] = {0};
static int8_t *L1CO [210] = {0};
static int8_t *L2CM [210] = {0};
static int8_t *L2CL [210] = {0};
static int8_t *L5I  [210] = {0};
static int8_t *L5Q  [210] = {0};
static int8_t *L6D  [ 10] = {0};
static int8_t *L6E  [ 10] = {0};
static int8_t *G1CA [  1] = {0};
static int8_t *G1OCD[ 64] = {0};
static int8_t *G1OCP[ 64] = {0};
static int8_t *G2OCP[ 64] = {0};
static int8_t *G3OCD[ 64] = {0};
static int8_t *G3OCP[ 64] = {0};
static int8_t *E1B  [ 50] = {0};
static int8_t *E1C  [ 50] = {0};
static int8_t *E1CS       = NULL;
static int8_t *E5AI [ 50] = {0};
static int8_t *E5AQ [ 50] = {0};
static int8_t *E5AIS      = NULL;
static int8_t *E5AQS[ 50] = {0};
static int8_t *E5BI [ 50] = {0};
static int8_t *E5BIS      = NULL;
static int8_t *E5BQ [ 50] = {0};
static int8_t *E5BQS[ 50] = {0};
static int8_t *E6B  [ 50] = {0};
static int8_t *E6C  [ 50] = {0};
static int8_t *E6CS [ 50] = {0};
static int8_t *B1I  [ 63] = {0};
static int8_t *B1CD [ 63] = {0};
static int8_t *B1CP [ 63] = {0};
static int8_t *B1CS [ 63] = {0};
static int8_t *B2AD [ 63] = {0};
static int8_t *B2AP [ 63] = {0};
static int8_t *B2AS [ 63] = {0};
static int8_t *B2BI [ 63] = {0};
static int8_t *B3I  [ 63] = {0};
static int8_t *I1SD [ 14] = {0};
static int8_t *I1SP [ 14] = {0};
static int8_t *I1SPO[ 14] = {0};
static int8_t *I5S  [ 14] = {0};
static int8_t *ISS  [ 14] = {0};

static int8_t *L1CA_G1    = NULL;
static int8_t *L1CA_G2    = NULL;
static int8_t *L1C_L_SEQ  = NULL;
static int8_t *L5_XA      = NULL;
static int8_t *L5_XB      = NULL;
static int8_t *G3OC_DC1   = NULL;
static int8_t *B1C_L_SEQ  = NULL;
static int8_t *B1C_L_SEQ_S = NULL;
static int8_t *B2AD_G1    = NULL;
static int8_t *B2AP_G1    = NULL;
static int8_t *B2A_L_SEQ  = NULL;
static int8_t *B2BI_G1    = NULL;
static int8_t *B3I_G1     = NULL;

// code tables -----------------------------------------------------------------
static const uint16_t L1CA_G2_delay[] = { // PRN 1 - 210
       5,   6,   7,   8,  17,  18, 139, 140, 141, 251, 252, 254, 255, 256, 257,
     258, 469, 470, 471, 472, 473, 474, 509, 512, 513, 514, 515, 516, 859, 860,
     861, 862, 863, 950, 947, 948, 950,  67, 103,  91,  19, 679, 225, 625, 946,
     638, 161,1001, 554, 280, 710, 709, 775, 864, 558, 220, 397,  55, 898, 759,
     367, 299,1018, 729, 695, 780, 801, 788, 732,  34, 320, 327, 389, 407, 525,
     405, 221, 761, 260, 326, 955, 653, 699, 422, 188, 438, 959, 539, 879, 677,
     586, 153, 792, 814, 446, 264,1015, 278, 536, 819, 156, 957, 159, 712, 885,
     461, 248, 713, 126, 807, 279, 122, 197, 693, 632, 771, 467, 647, 203, 145,
     175,  52,  21, 237, 235, 886, 657, 634, 762, 355,1012, 176, 603, 130, 359,
     595,  68, 386, 797, 456, 499, 883, 307, 127, 211, 121, 118, 163, 628, 853,
     484, 289, 811, 202,1021, 463, 568, 904, 670, 230, 911, 684, 309, 644, 932,
      12, 314, 891, 212, 185, 675, 503, 150, 395, 345, 846, 798, 992, 357, 995,
     877, 112, 144, 476, 193, 109, 445, 291,  87, 399, 292, 901, 339, 208, 711,
     189, 263, 537, 663, 942, 173, 900,  30, 500, 935, 556, 373,  85, 652, 310
};

static const uint16_t L1CP_weil_idx[] = { // PRN 1 - 210
    5111, 5109, 5108, 5106, 5103, 5101, 5100, 5098, 5095, 5094, 5093, 5091,
    5090, 5081, 5080, 5069, 5068, 5054, 5044, 5027, 5026, 5014, 5004, 4980,
    4915, 4909, 4893, 4885, 4832, 4824, 4591, 3706, 5092, 4986, 4965, 4920,
    4917, 4858, 4847, 4790, 4770, 4318, 4126, 3961, 3790, 4911, 4881, 4827,
    4795, 4789, 4725, 4675, 4539, 4535, 4458, 4197, 4096, 3484, 3481, 3393,
    3175, 2360, 1852, 5065, 5063, 5055, 5012, 4981, 4952, 4934, 4932, 4786,
    4762, 4640, 4601, 4563, 4388, 3820, 3687, 5052, 5051, 5047, 5039, 5015,
    5005, 4984, 4975, 4974, 4972, 4962, 4913, 4907, 4903, 4833, 4778, 4721,
    4661, 4660, 4655, 4623, 4590, 4548, 4461, 4442, 4347, 4259, 4256, 4166,
    4155, 4109, 4100, 4023, 3998, 3979, 3903, 3568, 5088, 5050, 5020, 4990,
    4982, 4966, 4949, 4947, 4937, 4935, 4906, 4901, 4872, 4865, 4863, 4818,
    4785, 4781, 4776, 4775, 4754, 4696, 4690, 4658, 4607, 4599, 4596, 4530,
    4524, 4451, 4441, 4396, 4340, 4335, 4296, 4267, 4168, 4149, 4097, 4061,
    3989, 3966, 3789, 3775, 3622, 3523, 3515, 3492, 3345, 3235, 3169, 3157,
    3082, 3072, 3032, 3030, 4582, 4595, 4068, 4871, 4514, 4439, 4122, 4948,
    4774, 3923, 3411, 4745, 4195, 4897, 3047, 4185, 4354, 5077, 4042, 2111,
    4311, 5024, 4352, 4678, 5034, 5085, 3646, 4868, 3668, 4211, 2883, 2850,
    2815, 2542, 2492, 2376, 2036, 1920
};

static const uint16_t L1CP_ins_idx[] = { // PRN 1 - 210
     412,  161,    1,  303,  207, 4971, 4496,    5, 4557,  485,  253, 4676,
       1,   66, 4485,  282,  193, 5211,  729, 4848,  982, 5955, 9805,  670,
     464,   29,  429,  394,  616, 9457, 4429, 4771,  365, 9705, 9489, 4193,
    9947,  824,  864,  347,  677, 6544, 6312, 9804,  278, 9461,  444, 4839,
    4144, 9875,  197, 1156, 4674,10035, 4504,    5, 9937,  430,    5,  355,
     909, 1622, 6284, 9429,   77,  932, 5973,  377,10000,  951, 6212,  686,
    9352, 5999, 9912, 9620,  635, 4951, 5453, 4658, 4800,   59,  318,  571,
     565, 9947, 4654,  148, 3929,  293,  178,10142, 9683,  137,  565,   35,
    5949,    2, 5982,  825, 9614, 9790, 5613,  764,  660, 4870, 4950, 4881,
    1151, 9977, 5122,10074, 4832,   77, 4698, 1002, 5549, 9606, 9228,  604,
    4678, 4854, 4122, 9471, 5026,  272, 1027,  317,  691,  509, 9708, 5033,
    9938, 4314,10140, 4790, 9823, 6093,  469, 1215,  799,  756, 9994, 4843,
    5271, 9661, 6255, 5203,  203,10070,   30,  103, 5692,   32, 9826,   76,
      59, 6831,  958, 1471,10070,  553, 5487,   55,  208,  645, 5268, 1873,
     427,  367, 1404, 5652,    5,  368,  451, 9595, 1030, 1324,  692, 9819,
    4520, 9911,  278,  642, 6330, 5508, 1872, 5445,10131,  422, 4918,  787,
    9864, 9753, 9859,  328,    1, 4733, 164,   135,  174,  132,  538,  176,
     198,  595,  574,  321,  596,  491
};

static const uint16_t L1CD_weil_idx[] = { // PRN 1 - 210
    5097, 5110, 5079, 4403, 4121, 5043, 5042, 5104, 4940, 5035, 4372, 5064,
    5084, 5048, 4950, 5019, 5076, 3736, 4993, 5060, 5061, 5096, 4983, 4783,
    4991, 4815, 4443, 4769, 4879, 4894, 4985, 5056, 4921, 5036, 4812, 4838,
    4855, 4904, 4753, 4483, 4942, 4813, 4957, 4618, 4669, 4969, 5031, 5038,
    4740, 4073, 4843, 4979, 4867, 4964, 5025, 4579, 4390, 4763, 4612, 4784,
    3716, 4703, 4851, 4955, 5018, 4642, 4840, 4961, 4263, 5011, 4922, 4317,
    3636, 4884, 5041, 4912, 4504, 4617, 4633, 4566, 4702, 4758, 4860, 3962,
    4882, 4467, 4730, 4910, 4684, 4908, 4759, 4880, 4095, 4971, 4873, 4561,
    4588, 4773, 4997, 4583, 4900, 4574, 4629, 4676, 4181, 5057, 4944, 4401,
    4586, 4699, 3676, 4387, 4866, 4926, 4657, 4477, 4359, 4673, 4258, 4447,
    4570, 4486, 4362, 4481, 4322, 4668, 3967, 4374, 4553, 4641, 4215, 3853,
    4787, 4266, 4199, 4545, 4208, 4485, 3714, 4407, 4182, 4203, 3788, 4471,
    4691, 4281, 4410, 3953, 3465, 4801, 4278, 4546, 3779, 4115, 4193, 3372,
    3786, 3491, 3812, 3594, 4028, 3652, 4224, 4334, 3245, 3921, 3840, 3514,
    2922, 4227, 3376, 3560, 4989, 4756, 4624, 4446, 4174, 4551, 3972, 4399,
    4562, 3133, 4157, 5053, 4536, 5067, 3905, 3721, 3787, 4674, 3436, 2673,
    4834, 4456, 4056, 3804, 3672, 4205, 3348, 4152, 3883, 3473, 3669, 3455,
    2318, 2945, 2947, 3220, 4052, 2953
};

static const uint16_t L1CD_ins_idx[] = { // PRN 1 - 210
     181,  359,   72, 1110, 1480, 5034, 4622,    1, 4547,  826, 6284, 4195,
     368,    1, 4796,  523,  151,  713, 9850, 5734,   34, 6142,  190,  644,
     467, 5384,  801,  594, 4450, 9437, 4307, 5906,  378, 9448, 9432, 5849,
    5547, 9546, 9132,  403, 3766,    3,  684, 9711,  333, 6124,10216, 4251,
    9893, 9884, 4627, 4449, 9798,  985, 4272,  126,10024,  434, 1029,  561,
     289,  638, 4353, 9899, 4629,  669, 4378, 4528, 9718, 5485, 6222,  672,
    1275, 6083, 5264,10167, 1085,  194, 5012, 4938, 9356, 5057,  866,    2,
     204, 9808, 4365,  162,  367,  201,   18,  251,10167,   21,  685,   92,
    1057,    3, 5756,   14, 9979, 9569,  515,  753, 1181, 9442,  669, 4834,
     541, 9933, 6683, 4828, 9710,10170, 9629,  260,   86, 5544,  923,  257,
     507, 4572, 4491,  341,  130,   79, 1142,  448,  875,  555, 1272, 5198,
    9529, 4459,10019, 9353, 9780,  375,  503, 4507,  875, 1246,    1, 4534,
       8, 9549, 6240,   22, 5652,10069, 4796, 4980,   27,   90, 9788,  715,
    9720,  301, 5450, 5215,   13, 1147, 4855, 1190, 1267, 1302,    1, 5007,
     549,  368, 6300, 5658, 4302,  851, 4353, 9618, 9652, 1232,  109,10174,
    6178, 1851, 1299,  325,10206, 9968,10191, 5438,10080,  219,  758, 2140,
    9753, 4799,10126,  241, 1245, 1274, 1456, 9967,  235,  512, 1078, 1078,
     953, 5647,  669, 1311, 5827,   15
};

static const uint16_t L1CO_S1_poly[] = { // PRN 1 - 210
    05111, 05421, 05501, 05403, 06417, 06141, 06351, 06501, 06205,
    06235, 07751, 06623, 06733, 07627, 05667, 05051, 07665, 06325,
    04365, 04745, 07633, 06747, 04475, 04225, 07063, 04423, 06651,
    04161, 07237, 04473, 05477, 06163, 07223, 06323, 07125, 07035,
    04341, 04353, 04107, 05735, 06741, 07071, 04563, 05755, 06127,
    04671, 04511, 04533, 05357, 05607, 06673, 06153, 07565, 07107,
    06211, 04321, 07201, 04451, 05411, 05141, 07041, 06637, 04577,
    05111, 05111, 05111, 05111, 05111, 05111, 05111, 05111, 05111,
    05111, 05111, 05111, 05111, 05111, 05111, 05111, 05111, 05111,
    05111, 05111, 05111, 05111, 05111, 05111, 05111, 05111, 05111,
    05111, 05111, 05111, 05111, 05111, 05111, 05111, 05111, 05111,
    05421, 05421, 05421, 05421, 05421, 05421, 05421, 05421, 05421,
    05421, 05421, 05421, 05421, 05421, 05421, 05421, 05421, 05421,
    05421, 05421, 05421, 05421, 05421, 05421, 05421, 05421, 05421,
    05421, 05421, 05421, 05421, 05421, 05421, 05421, 05421, 05421,
    05421, 05421, 05421, 05403, 05403, 05403, 05403, 05403, 05403,
    05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403,
    05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403,
    05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403,
    05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403,
    05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403,
    05403, 05403, 05403, 05403, 05403, 05403, 05403, 05403, 06501,
    06501, 06501, 06501, 06501, 06501, 06501, 06501, 06501, 06501,
    06501, 06501, 06501
};
static const uint16_t L1CO_S1_init[] = { // PRN 1 - 210
    03266, 02040, 01527, 03307, 03756, 03026, 00562, 00420, 03415,
    00337, 00265, 01230, 02204, 01440, 02412, 03516, 02761, 03750,
    02701, 01206, 01544, 01774, 00546, 02213, 03707, 02051, 03650,
    01777, 03203, 01762, 02100, 00571, 03710, 03535, 03110, 01426,
    00255, 00321, 03124, 00572, 01736, 03306, 01307, 03763, 01604,
    01021, 02624, 00406, 00114, 00077, 03477, 01000, 03460, 02607,
    02057, 03467, 00706, 02032, 01464, 00520, 01766, 03270, 00341,
    01740, 03664, 01427, 02627, 00701, 03460, 01373, 02540, 02004,
    02274, 01340, 00602, 02502, 00327, 02600, 00464, 03674, 03040,
    01153, 00747, 01770, 03772, 01731, 01672, 01333, 02705, 02713,
    03562, 03245, 03770, 03202, 03521, 03250, 02117, 00530, 03021,
    02511, 01562, 01067, 00424, 03402, 01326, 02142, 00733, 00504,
    01611, 02724, 00753, 03724, 02652, 01743, 00013, 03464, 02300,
    01334, 02175, 02564, 03075, 03455, 03627, 00617, 01324, 03506,
    02231, 01110, 01271, 03740, 03652, 01644, 03635, 03436, 03076,
    00434, 03340, 00054, 02446, 00025, 00150, 02746, 02723, 02601,
    03440, 01312, 00544, 02062, 00176, 03616, 01740, 03777, 00432,
    02466, 01667, 03601, 02706, 02022, 01363, 02331, 03556, 02205,
    03734, 02115, 00010, 02140, 03136, 00272, 03264, 02017, 02505,
    03532, 00647, 01542, 02154, 03734, 02621, 02711, 00217, 03503,
    03457, 03750, 02525, 00113, 00265, 01711, 00552, 00675, 01706,
    03513, 01135, 00566, 00500, 00254, 03445, 02542, 01257, 00211,
    00534, 01420, 03401, 00714, 00613, 02475, 02572, 03265, 01250,
    01711, 02704, 00135
};

static const uint16_t L1CO_S2_init[] = { // PRN 64 - 210
    03035, 01557, 00237, 02527, 03307, 01402, 01225, 00607, 00351,
    03724, 01675, 02625, 01030, 01443, 03277, 01132, 00572, 01241,
    00535, 01366, 00041, 00561, 00122, 01205, 03753, 02543, 03031,
    02260, 03773, 03156, 02215, 00146, 02413, 02564, 03310, 02267,
    03120, 00064, 01042, 00476, 01020, 00431, 00216, 02736, 02527,
    02431, 01013, 00524, 00726, 01042, 03362, 01364, 03354, 00623,
    00145, 00214, 00223, 00151, 02405, 02522, 03235, 00452, 02617,
    01300, 01430, 00773, 00772, 03561, 00607, 00420, 00527, 03770,
    02536, 02233, 03366, 03766, 03554, 02060, 02070, 00713, 03366,
    03247, 02776, 01244, 02102, 01712, 01245, 03344, 01277, 00165,
    02131, 03623, 00141, 00421, 03032, 02065, 03024, 02663, 02274,
    02114, 01664, 00413, 01512, 00135, 02737, 01015, 01075, 01255,
    03473, 02716, 00101, 01105, 01407, 03407, 01046, 03237, 00154,
    03010, 02245, 02051, 02144, 01743, 02511, 03410, 01414, 01275,
    02257, 02331, 00276, 03261, 01760, 00430, 03477, 01676, 01636,
    02411, 01473, 02266, 02104, 02070, 01766, 00711, 02533, 00353,
    01744, 00053, 02222
};

static const uint32_t L2CM_R_init_1[] = { // PRN 1 - 63
    0742417664, 0756014035, 0002747144, 0066265724, 0601403471,
    0703232733, 0124510070, 0617316361, 0047541621, 0733031046,
    0713512145, 0024437606, 0021264003, 0230655351, 0001314400,
    0222021506, 0540264026, 0205521705, 0064022144, 0120161274,
    0044023533, 0724744327, 0045743577, 0741201660, 0700274134,
    0010247261, 0713433445, 0737324162, 0311627434, 0710452007,
    0722462133, 0050172213, 0500653703, 0755077436, 0136717361,
    0756675453, 0435506112, 0771353753, 0226107701, 0022025110,
    0402466344, 0752566114, 0702011164, 0041216771, 0047457275,
    0266333164, 0713167356, 0060546335, 0355173035, 0617201036,
    0157465571, 0767360553, 0023127030, 0431343777, 0747317317,
    0045706125, 0002744276, 0060036467, 0217744147, 0603340174,
    0326616775, 0063240065, 0111460621
};

static const uint32_t L2CM_R_init_2[] = { // PRN 159 - 210
    0604055104, 0157065232, 0013305707, 0603552017, 0230461355,
    0603653437, 0652346475, 0743107103, 0401521277, 0167335110,
    0014013575, 0362051132, 0617753265, 0216363634, 0755561123,
    0365304033, 0625025543, 0054420334, 0415473671, 0662364360,
    0373446602, 0417564100, 0000526452, 0226631300, 0113752074,
    0706134401, 0041352546, 0664630154, 0276524255, 0714720530,
    0714051771, 0044526647, 0207164322, 0262120161, 0204244652,
    0202133131, 0714351204, 0657127260, 0130567507, 0670517677,
    0607275514, 0045413633, 0212645405, 0613700455, 0706202440,
    0705056276, 0020373522, 0746013617, 0132720621, 0434015513,
    0566721727, 0140633660
};

static const uint32_t L2CL_R_init_1[] = { // PRN 1 - 63
    0624145772, 0506610362, 0220360016, 0710406104, 0001143345,
    0053023326, 0652521276, 0206124777, 0015563374, 0561522076,
    0023163525, 0117776450, 0606516355, 0003037343, 0046515565,
    0671511621, 0605402220, 0002576207, 0525163451, 0266527765,
    0006760703, 0501474556, 0743747443, 0615534726, 0763621420,
    0720727474, 0700521043, 0222567263, 0132765304, 0746332245,
    0102300466, 0255231716, 0437661701, 0717047302, 0222614207,
    0561123307, 0240713073, 0101232630, 0132525726, 0315216367,
    0377046065, 0655351360, 0435776513, 0744242321, 0024346717,
    0562646415, 0731455342, 0723352536, 0000013134, 0011566642,
    0475432222, 0463506741, 0617127534, 0026050332, 0733774235,
    0751477772, 0417631550, 0052247456, 0560404163, 0417751005,
    0004302173, 0715005045, 0001154457
};

static const uint32_t L2CL_R_init_2[] = { // PRN 159 - 210
    0605253024, 0063314262, 0066073422, 0737276117, 0737243704,
    0067557532, 0227354537, 0704765502, 0044746712, 0720535263,
    0733541364, 0270060042, 0737176640, 0133776704, 0005645427,
    0704321074, 0137740372, 0056375464, 0704374004, 0216320123,
    0011322115, 0761050112, 0725304036, 0721320336, 0443462103,
    0510466244, 0745522652, 0373417061, 0225526762, 0047614504,
    0034730440, 0453073141, 0533654510, 0377016461, 0235525312,
    0507056307, 0221720061, 0520470122, 0603764120, 0145604016,
    0051237167, 0033326347, 0534627074, 0645230164, 0000171400,
    0022715417, 0135471311, 0137422057, 0714426456, 0640724672,
    0501254540, 0513322453
};

static const uint16_t L5I_XB_adv[] = { // PRN 1 - 210
     266,  365,  804, 1138, 1509, 1559, 1756, 2084, 2170, 2303, 2527, 2687,
    2930, 3471, 3940, 4132, 4332, 4924, 5343, 5443, 5641, 5816, 5898, 5918,
    5955, 6243, 6345, 6477, 6518, 6875, 7168, 7187, 7329, 7577, 7720, 7777,
    8057, 5358, 3550, 3412,  819, 4608, 3698,  962, 3001, 4441, 4937, 3717,
    4730, 7291, 2279, 7613, 5723, 7030, 1475, 2593, 2904, 2056, 2757, 3756,
    6205, 5053, 6437, 7789, 2311, 7432, 5155, 1593, 5841, 5014, 1545, 3016,
    4875, 2119,  229, 7634, 1406, 4506, 1819, 7580, 5446, 6053, 7958, 5267,
    2956, 3544, 1277, 2996, 1758, 3360, 2718, 3754, 7440, 2781, 6756, 7314,
     208, 5252,  696,  527, 1399, 5879, 6868,  217, 7681, 3788, 1337, 2424,
    4243, 5686, 1955, 4791,  492, 1518, 6566, 5349,  506,  113, 1953, 2797,
     934, 3023, 3632, 1330, 4909, 4867, 1183, 3990, 6217, 1224, 1733, 2319,
    3928, 2380,  841, 5049, 7027, 1197, 7208, 8000,  152, 6762, 3745, 4723,
    5502, 4796,  123, 8142, 5091, 7875,  330, 5272, 4912,  374, 2045, 6616,
    6321, 7605, 2570, 2419, 1234, 1922, 4317, 5110,  825,  958, 1089, 7813,
    6058, 7703, 6702, 1714, 6371, 2281, 1986, 6282, 3201, 3760, 1056, 6233,
    1150, 2823, 6250,  645, 2401, 1639, 2946, 7091,  923, 7045, 6493, 1706,
    5836,  926, 6086,  950, 5905, 3240, 6675, 3197, 1555, 3589, 4555, 5671,
    6948, 4664, 2086, 5950, 5521, 1515
};

static const uint16_t L5Q_XB_adv[] = { // PRN 1 - 210
    1701,  323, 5292, 2020, 5429, 7136, 1041, 5947, 4315,  148,  535, 1939,
    5206, 5910, 3595, 5135, 6082, 6990, 3546, 1523, 4548, 4484, 1893, 3961,
    7106, 5299, 4660,  276, 4389, 3783, 1591, 1601,  749, 1387, 1661, 3210,
     708, 4226, 5604, 6375, 3056, 1772, 3662, 4401, 5218, 2838, 6913, 1685,
    1194, 6963, 5001, 6694,  991, 7489, 2441,  639, 2097, 2498, 6470, 2399,
     242, 3768, 1186, 5246, 4259, 5907, 3870, 3262, 7387, 3069, 2999, 7993,
    7849, 4157, 5031, 5986, 4833, 5739, 7846,  898, 2022, 7446, 6404,  155,
    7862, 7795, 6121, 4840, 6585,  429, 6020,  200, 1664, 1499, 7298, 1305,
    7323, 7544, 4438, 2485, 3387, 7319, 1853, 5781, 1874, 7555, 2132, 6441,
    6722, 1192, 2588, 2188,  297, 1540, 4138, 5231, 4789,  659,  871, 6837,
    1393, 7383,  611, 4920, 5416, 1611, 2474,  118, 1382, 1092, 7950, 7223,
    1769, 4721, 1252, 5147, 2165, 7897, 4054, 3498, 6571, 2858, 8126, 7017,
    1901,  181, 1114, 5195, 7479, 4186, 3904, 7128, 1396, 4513, 5967, 2580,
    2575, 7961, 2598, 4508, 2090, 3685, 7748,  684,  913, 5558, 2894, 5858,
    6432, 3813, 3573, 7523, 5280, 3376, 7424, 2918, 5793, 1747, 7079, 2921,
    2490, 4119, 3373,  977,  681, 4273, 5419, 5626, 1266, 5804, 2414, 6444,
    4757,  427, 5452, 5182, 6606, 6531, 4268, 3115, 6835,  862, 4856, 2765,
      37, 1943, 7977, 2512, 4451, 4071
};

static const uint32_t L6D_R_init[] = { // PRN 193 - 202
    00255021, 00327455, 00531421, 00615350, 00635477, 01547457,
    01715254, 01741247, 02322713, 02534561
};

static const uint32_t L6E_R_init[] = { // PRN 203 - 212
    01142153, 01723711, 03672765, 00030404, 00000546, 01306224,
    03642512, 00255043, 02020075, 03571777
};

static const uint16_t E5AI_X2_init[] = { // PRN 1 - 50
    030305, 014234, 027213, 020577, 023312, 033463, 015614, 012537,
    001527, 030236, 027344, 007272, 036377, 017046, 006434, 015405,
    024252, 011631, 024776, 000630, 011560, 017272, 027445, 031702,
    013012, 014401, 034727, 022627, 030623, 027256, 001520, 014211,
    031465, 022164, 033516, 002737, 021316, 035425, 035633, 024655,
    014054, 027027, 006604, 031455, 034465, 025273, 020763, 031721,
    017312, 013277
};

static const uint16_t E5AQ_X2_init[] = { // PRN 1 - 50
    025652, 005142, 024723, 031751, 027366, 024660, 033655, 027450,
    007626, 001705, 012717, 032122, 016075, 016644, 037556, 002477,
    002265, 006430, 025046, 012735, 004262, 011230, 000037, 006137,
    004312, 020606, 011162, 022252, 030533, 024614, 007767, 032705,
    005052, 027553, 003711, 002041, 034775, 005274, 037356, 016205,
    036270, 006600, 026773, 017375, 035267, 036255, 012044, 026442,
    021621, 025411
};

static const uint16_t E5BI_X2_init[] = { // PRN 1 - 50
    007220, 026047, 000252, 017166, 014161, 002540, 001537, 026023,
    001725, 020637, 002364, 027731, 030640, 034174, 006464, 007676,
    032231, 010353, 000755, 026077, 011644, 011537, 035115, 020452,
    034645, 025664, 021403, 032253, 002337, 030777, 027122, 022377,
    036175, 033075, 033151, 013134, 007433, 010216, 035466, 002533,
    005351, 030121, 014010, 032576, 030326, 037433, 026022, 035770,
    006670, 012017
};

static const uint16_t E5BQ_X2_init[] = { // PRN 1 - 50
    003331, 006143, 025322, 023371, 000413, 036235, 017750, 004745,
    013005, 037140, 030155, 020237, 003461, 031662, 027146, 005547,
    002456, 030013, 000322, 010761, 026767, 036004, 030713, 007662,
    021610, 020134, 011262, 010706, 034143, 011051, 025460, 017665,
    032354, 021230, 020146, 011362, 037246, 016344, 015034, 025471,
    025646, 022157, 004336, 016356, 004075, 002626, 011706, 037011,
    027041, 031024
};

static const uint8_t B1I_ph_sel[][3] = { // PRN 1 - 63
    {1, 3}    , {1, 4}    , {1, 5}   , {1, 6}    , {1, 8}    , {1, 9}    ,
    {1, 10}   , {1, 11}   , {2, 7}   , {3, 4}    , {3, 5}    , {3, 6}    ,
    {3, 8}    , {3, 9}    , {3, 10}  , {3, 11}   , {4, 5}    , {4, 6}    ,
    {4, 8}    , {4, 9}    , {4, 10}  , {4, 11}   , {5, 6}    , {5, 8}    ,
    {5, 9}    , {5, 10}   , {5, 11}  , {6, 8}    , {6, 9}    , {6, 10}   ,
    {6, 11}   , {8, 9}    , {8, 10}  , {8, 11}   , {9, 10}   , {9, 11}   ,
    {10, 11}  , {1, 2, 7} , {1, 3, 4}, {1, 3, 6} , {1, 3, 8} , {1, 3, 10},
    {1, 3, 11}, {1, 4, 5} , {1, 4, 9}, {1, 5, 6} , {1, 5, 8} , {1, 5, 10},
    {1, 5, 11}, {1, 6, 9} , {1, 8, 9}, {1, 9, 10}, {1, 9, 11}, {2, 3, 7} ,
    {2, 5, 7} , {2, 7, 9} , {3, 4, 5}, {3, 4, 9} , {3, 5, 6} , {3, 5, 8} ,
    {3, 5, 10}, {3, 5, 11}, {3, 6, 9}
};

static const uint16_t B1CD_ph_diff[] = { // PRN 1 - 63
    2678, 4802,  958,  859, 3843, 2232,  124, 4352, 1816, 1126, 1860, 4800,
    2267,  424, 4192, 4333, 2656, 4148,  243, 1330, 1593, 1470,  882, 3202,
    5095, 2546, 1733, 4795, 4577, 1627, 3638, 2553, 3646, 1087, 1843,  216,
    2245,  726, 1966,  670, 4130,   53, 4830,  182, 2181, 2006, 1080, 2288,
    2027,  271,  915,  497,  139, 3693, 2054, 4342, 3342, 2592, 1007,  310,
    4203,  455, 4318
};

static const uint16_t B1CD_trunc_pnt[] = { // PRN 1 - 63
     699,  694, 7318, 2127,  715, 6682, 7850, 5495, 1162, 7682, 6792, 9973,
    6596, 2092,   19,10151, 6297, 5766, 2359, 7136, 1706, 2128, 6827,  693,
    9729, 1620, 6805,  534,  712, 1929, 5355, 6139, 6339, 1470, 6867, 7851,
    1162, 7659, 1156, 2672, 6043, 2862,  180, 2663, 6940, 1645, 1582,  951,
    6878, 7701, 1823, 2391, 2606,  822, 6403,  239,  442, 6769, 2560, 2502,
    5072, 7268,  341
};

static const uint16_t B1CP_ph_diff[] = { // PRN 1 - 63
     796,  156, 4198, 3941, 1374, 1338, 1833, 2521, 3175,  168, 2715, 4408,
    3160, 2796,  459, 3594, 4813,  586, 1428, 2371, 2285, 3377, 4965, 3779,
    4547, 1646, 1430,  607, 2118, 4709, 1149, 3283, 2473, 1006, 3670, 1817,
     771, 2173,  740, 1433, 2458, 3459, 2155, 1205,  413,  874, 2463, 1106,
    1590, 3873, 4026, 4272, 3556,  128, 1200,  130, 4494, 1871, 3073, 4386,
    4098, 1923, 1176
};

static const uint16_t B1CP_trunc_pnt[] = { // PRN 1 - 63
    7575, 2369, 5688,  539, 2270, 7306, 6457, 6254, 5644, 7119, 1402, 5557,
    5764, 1073, 7001, 5910,10060, 2710, 1546, 6887, 1883, 5613, 5062, 1038,
   10170, 6484, 1718, 2535, 1158,  526, 7331, 5844, 6423, 6968, 1280, 1838,
    1989, 6468, 2091, 1581, 1453, 6252, 7122, 7711, 7216, 2113, 1095, 1628,
    1713, 6102, 6123, 6070, 1115, 8047, 6795, 2575,   53, 1729, 6388,  682,
    5565, 7160, 2277
};

static const uint16_t B1CS_ph_diff[] = { // PRN 1 - 63
     269, 1448, 1028, 1324,  822,    5,  155,  458,  310,  959, 1238, 1180,
    1288,  334,  885, 1362,  181, 1648,  838,  313,  750,  225, 1477,  309,
     108, 1457,  149,  322,  271,  576, 1103,  450,  399,  241, 1045,  164,
     513,  687,  422,  303,  324,  495,  725,  780,  367,  882,  631,   37,
     647, 1043,   24,  120,  134,  136,  158,  214,  335,  340,  661,  889,
     929, 1002, 1149
};

static const uint16_t B1CS_trunc_pnt[] = { // PRN 1 - 63
    1889, 1268, 1593, 1186, 1239, 1930,  176, 1696,   26, 1344, 1271, 1182,
    1381, 1604, 1333, 1185,   31,  704, 1190, 1646, 1385,  113,  860, 1656,
    1921, 1173, 1928,   57,  150, 1214, 1148, 1458, 1519, 1635, 1257, 1687,
    1382, 1514,    1, 1583, 1806, 1664, 1338, 1111, 1706, 1543, 1813,  228,
    2871, 2884, 1823,   75,   11,   63, 1937,   22, 1768, 1526, 1402, 1445,
    1680, 1290, 1245
};

static const uint16_t B2AD_G2_init[] = { // PRN 1 - 63
    0x1025, 0x1034, 0x10AD, 0x114F, 0x1155, 0x11AE, 0x11EE, 0x11FB,
    0x1329, 0x13DA, 0x1435, 0x1444, 0x1455, 0x145B, 0x145C, 0x14A3,
    0x14F7, 0x1501, 0x153E, 0x15AB, 0x15B1, 0x1653, 0x1662, 0x1698,
    0x16B6, 0x16F2, 0x16FF, 0x1712, 0x173C, 0x17A1, 0x17C8, 0x17D4,
    0x17EB, 0x17F3, 0x1851, 0x1894, 0x18B7, 0x1911, 0x1919, 0x19AB,
    0x19B1, 0x19D2, 0x1A55, 0x1A74, 0x1ACB, 0x1B57, 0x1C34, 0x1C83,
    0x1C8B, 0x1CA3, 0x1CA8, 0x1D3B, 0x1D97, 0x1E48, 0x1E94, 0x1E99,
    0x1EDA, 0x1EF8, 0x1EFF, 0x1FB5, 0x0402, 0x1BF5, 0x03D2
};

static const uint16_t B2AP_G2_init[] = { // PRN 1 - 63
    0x1025, 0x1034, 0x10AD, 0x114F, 0x1155, 0x11AE, 0x11EE, 0x11FB,
    0x1329, 0x13DA, 0x1435, 0x1444, 0x1455, 0x145B, 0x145C, 0x14A3,
    0x14F7, 0x1501, 0x153E, 0x15AB, 0x15B1, 0x1653, 0x1662, 0x1698,
    0x16B6, 0x16F2, 0x16FF, 0x1712, 0x173C, 0x17A1, 0x17C8, 0x17D4,
    0x17EB, 0x17F3, 0x1851, 0x1894, 0x18B7, 0x1911, 0x1919, 0x19AB,
    0x19B1, 0x19D2, 0x1A55, 0x1A74, 0x1ACB, 0x1B57, 0x1C34, 0x1C83,
    0x1C8B, 0x1CA3, 0x1CA8, 0x1D3B, 0x1D97, 0x1E48, 0x1E94, 0x1E99,
    0x1EDA, 0x1EF8, 0x1EFF, 0x1FB5, 0x1486, 0x05F8, 0x0355
};

static const uint16_t B2AS_ph_diff[] = { // PRN 1 - 63
     123,   55,   40,  139,   31,  175,  350,  450,  478,    8,   73,   97,
     213,  407,  476,    4,   15,   47,  163,  280,  322,  353,  375,  510,
     332,    7,   13,   16,   18,   25,   50,   81,  118,  127,  132,  134,
     164,  177,  208,  249,  276,  349,  439,  477,  498,   88,  155,  330,
       3,   21,   84,  111,  128,  153,  197,  199,  214,  256,  265,  291,
     324,  326,  340
};

static const uint16_t B2AS_trunc_pnt[] = { // PRN 1 - 63
     138,  570,  351,   77,  885,  247,  413,  180,    3,   26,   17,  172,
      30, 1008,  646,  158,  170,   99,   53,  179,  925,  114,   10,  584,
      60,    3,  684,  263,  545,   22,  546,  190,  303,  234,   38,  822,
      57,  668,  697,   93,   18,   66,  318,  133,   98,   70,  132,   26,
     354,   58,   41,  182,  944,  205,   23,    1,  792,  641,   83,    7,
     111,   96,   92
};

static const uint16_t B2BI_G2_init[] = { // PRN 1 - 63
    0x1025, 0x1034, 0x10AD, 0x114F, 0x1155, 0x11AE, 0x11EE, 0x11FB,
    0x1329, 0x13DA, 0x1435, 0x1444, 0x1455, 0x145B, 0x145C, 0x14A3,
    0x14F7, 0x1501, 0x153E, 0x15AB, 0x15B1, 0x1653, 0x1662, 0x1698,
    0x16B6, 0x16F2, 0x16FF, 0x1712, 0x173C, 0x17A1, 0x17C8, 0x17D4,
    0x17EB, 0x17F3, 0x1851, 0x1894, 0x18B7, 0x1911, 0x1919, 0x19AB,
    0x19B1, 0x19D2, 0x1A55, 0x1A74, 0x1ACB, 0x1B57, 0x1C34, 0x1C83,
    0x1C8B, 0x1CA3, 0x1CA8, 0x1D3B, 0x1D97, 0x1E48, 0x1E94, 0x1E99,
    0x1EDA, 0x1EF8, 0x1EFF, 0x1FB5, 0x1FBD, 0x0B85, 0x0B3B
};

static const uint16_t B3I_G2_init[] = { // PRN 1 - 63
    0x15FF, 0x1E2B, 0x178A, 0x1FFB, 0x191F, 0x1264, 0x1FD2, 0x1DFD,
    0x1402, 0x041B, 0x1D70, 0x059E, 0x0C95, 0x0E26, 0x1189, 0x1C7C,
    0x04C5, 0x00EC, 0x1157, 0x02DE, 0x042D, 0x058A, 0x02CF, 0x0662,
    0x0748, 0x0929, 0x16D3, 0x15E2, 0x02F5, 0x0FFF, 0x0D8F, 0x1589,
    0x12AB, 0x19A5, 0x1A5D, 0x1F74, 0x0567, 0x1D10, 0x1B90, 0x1ACE,
    0x1034, 0x0BD9, 0x0DBC, 0x1A71, 0x0722, 0x0AC5, 0x13E6, 0x1F48,
    0x0149, 0x10AC, 0x1E4C, 0x098F, 0x0018, 0x1004, 0x06A6, 0x1646,
    0x0E78, 0x05CA, 0x19F6, 0x1245, 0x0E20, 0x0642, 0x044E
};

static const uint16_t I5S_G2_init[] = { // PRN 1 - 14
    0x03A7, 0x0026, 0x0234, 0x0172, 0x03B0, 0x006B, 0x0014, 0x0130,
    0x0098, 0x0364, 0x004C, 0x037C, 0x02D2, 0x01EA
};

static const uint16_t ISS_G2_init[] = { // PRN 1 - 14
    0x00EF, 0x017D, 0x0231, 0x00AB, 0x0291, 0x012C, 0x008E, 0x0126,
    0x030E, 0x02BE, 0x0391, 0x0369, 0x0145, 0x010D
};

static const uint64_t I1SD_R0_init[] = { // PRN 1 -14
    0x063D70B50D5B64, 0x76058F5475E4B0, 0x37D2F074FED295, 0x7E737E2ADF0BC1,
    0x718B5157F80E9E, 0x64C4B97DAE6753, 0x66F0F9CCE0A97C, 0x0254B975B60383,
    0x0091026C0910F5, 0x074BE51B3AF948, 0x734EEE6F471DE8, 0x77074F6C4181F3,
    0x7D457AA2ADE0AD, 0x1649006091465D
};

static const uint64_t I1SD_R1_init[] = { // PRN 1 -14
    0x1FF9721B874F80, 0x04F6D6D674B7C3, 0x2F17C1C778846A, 0x2920BBF796518D,
    0x51CA3936524FFD, 0x0FD2A5D6F6922C, 0x0D22D7133CBFC6, 0x4AFD02709873B4,
    0x299078F1B6FB54, 0x15638997825762, 0x2F6F9633538CDE, 0x59A5D67F687EC6,
    0x4F0C30BF5B3A0A, 0x73E795C57E19BB
};

static const uint16_t I1SD_C_init[] = { // PRN 1 -14
    0x0014, 0x0014, 0x0006, 0x0014, 0x0014, 0x0006, 0x0014, 0x0006,
    0x0006, 0x0006, 0x0014, 0x0006, 0x0014, 0x0006
};

static const uint64_t I1SP_R0_init[] = { // PRN 1 -14
    0x12FE3D0AE884C3, 0x30638515D33FCF, 0x3CCD53247E1C50, 0x027F3E65ED0C24,
    0x0DB7DD9BEC8DD3, 0x024BFAF5ABC21B, 0x0BFEFCB8EA13D8, 0x2161C00EE3808E,
    0x28253DEB538E14, 0x017D7A7CD16977, 0x366E99436BE257, 0x651C81DC3890EE,
    0x79D6273901EC48, 0x3C7815D839828A
};

static const uint64_t I1SP_R1_init[] = { // PRN 1 -14
    0x76E8F724A15EA5, 0x181A2F303D23DF, 0x278066D207D7A5, 0x31786E14C2045F,
    0x66B59E5C1069CB, 0x467A6895BCB117, 0x46C309A8B40404, 0x12B7C8761471AA,
    0x7B770DE0ED3105, 0x49CBF339896131, 0x0D584F5D59CAF8, 0x490C0AEC2962C5,
    0x44C454BDE6DEA3, 0x420E6B88D26357
};

static const uint16_t I1SP_C_init[] = { // PRN 1 -14
    0x0008, 0x0000, 0x0008, 0x0000, 0x0008, 0x0008, 0x0000, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0008, 0x0008, 0x0000
};

static const uint16_t I1SPO_R0_init[] = { // PRN 1 -14
    0x01BB, 0x01E8, 0x0301, 0x01B6, 0x0118, 0x00FC, 0x0065, 0x03C5,
    0x00CC, 0x021A, 0x0049, 0x01AB, 0x0170, 0x00B3
};

static const uint16_t I1SPO_R1_init[] = { // PRN 1 -14
    0x0130, 0x0182, 0x0391, 0x0173, 0x02C6, 0x02AF, 0x0388, 0x0050,
    0x02FC, 0x0115, 0x0304, 0x01DE, 0x0273, 0x026A
};

static int8_t NH10[] = { // 10 bits Neuman-Hoffman code
    -1, -1, -1, -1, 1, 1, -1, 1, -1, 1
};
 
static int8_t NH20[] = { // 20 bits Neuman-Hoffman code
   -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1
};

static int8_t BC[] = { // Baker code
   -1, -1, -1, 1, -1
};

static int8_t MC[] = { // Manchester code
   -1, 1
};

static int8_t G2OCP_OC2[] = { // GLONASS L2OCP OC2
   -1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, -1, -1, -1,
   -1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, -1,
   -1, 1, -1, -1, -1, 1, -1
};

static int8_t BOC[] = {-1, 1}; // BOC(k,k) sub-carrier

// upper cases of signal string ------------------------------------------------
static void sig_upper(const char *sig, char *Sig)
{
    int i;
    
    for (i = 0; i < 15; i++) {
        if (!(Sig[i] = (char)toupper(sig[i]))) break;
    }
    Sig[i] = '\0';
}

// modulation of code by sub-carrier ------------------------------------------
static int8_t *mod_code(const int8_t *code, int N, const int8_t *sub_carr,
    int n)
{
    int8_t *code_mod = (int8_t *)sdr_malloc(N * n);
    
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < n; j++) {
            code_mod[i*n+j] = -code[i] * sub_carr[j];
        }
    }
    return code_mod;
}

// read code HEX strings -------------------------------------------------------
static int8_t *read_code_hex(const char *str, int N)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    
    for (int i = 0; i < (N + 3) / 4; i++) {
        unsigned int hex;
        if (sscanf(str + i, "%1X", &hex) != 1) continue;
        for (int j = 0; j < 4 && i * 4 + j < N; j++) {
            code[i*4+j] = CHIP[(hex >> (3 - j)) & 1];
        }
    }
    return code;
}

// reverse bits in shift register ----------------------------------------------
int32_t rev_reg(int32_t R, int N)
{
    int32_t RR = 0;
    
    for (int i = 0; i < N; i++) {
        RR = (RR << 1) | ((R >> i) & 1);
    }
    return RR;
}

// generate code by LFSR  ------------------------------------------------------
int8_t *LFSR(int N, int32_t R, int32_t tap, int n)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    
    for (int i = 0; i < N; i++) {
        code[i] = CHIP[R & 1];
        R = (sdr_xor_bits(R & tap) << (n - 1)) | (R >> 1);
    }
    return code;
}

// generate code by XOR of 2 codes ---------------------------------------------
int8_t *xor_code(const int8_t *code1, const int8_t *code2, int N)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    
    for (int i = 0; i < N; i++) {
        code[i] = -code1[i] * code2[i];
    }
    return code;
}

// generate L1C/A G1 code ------------------------------------------------------
static int8_t *gen_code_L1CA_G1(int N)
{
    return LFSR(N, 0x3FF, 0x081, 10);
}

// generate L1C/A G2 code -------------------------------------------------------
static int8_t *gen_code_L1CA_G2(int N)
{
    return LFSR(N, 0x3FF, 0x197, 10);
}

// generate L1C/A code ([1]) ----------------------------------------------------
static int8_t *gen_code_L1CA(int prn, int *N)
{
    if (prn < 1 || prn > 210) {
        return NULL;
    }
    *N = 1023;
    if (!L1CA[prn-1]) {
        if (!L1CA_G1) {
            L1CA_G1 = gen_code_L1CA_G1(*N);
            L1CA_G2 = gen_code_L1CA_G2(*N);
        }
        L1CA[prn-1] = (int8_t *)sdr_malloc(*N);
        for (int i = 0; i < *N; i++) {
            int j = (i + (*N) - L1CA_G2_delay[prn-1]) % (*N);
            L1CA[prn-1][i] = -L1CA_G1[i] * L1CA_G2[j];
        }
    }
    return L1CA[prn-1];
}

// generate L1S code ([2]) -----------------------------------------------------
static int8_t *gen_code_L1S(int prn, int *N)
{
    if (prn < 183 || prn > 191) {
        return NULL;
    }
    return gen_code_L1CA(prn, N);
}

// generate L1C/B code ([3]) ----------------------------------------------------
static int8_t *gen_code_L1CB(int prn, int *N)
{
    if (prn != 198 && (prn < 202 || prn > 206)) {
        return NULL;
    }
    int8_t *code_L1CA = gen_code_L1CA(prn, N);
    int8_t *code = mod_code(code_L1CA, *N, BOC, 2); // BOC(1,1)
    *N *= 2;
    return code;
}

// generate Legendre sequence --------------------------------------------------
static int8_t *gen_legendre_seq(int N)
{
    int8_t *L = (int8_t *)sdr_malloc(N);
    
    for (int i = 0; i < N; i++) {
        L[i] = -1;
    }
    for (int i = 1; i < N; i++) {
        L[(i * i) % N] = 1;
    }
    return L;
}

// generate L1CP/D code ([7]) --------------------------------------------------
static int8_t *gen_code_L1CPD(int N, int w, int p)
{
    static const int8_t ins_code[] = {-1, 1, 1, -1, 1, -1, -1};
    
    if (!L1C_L_SEQ) {
        L1C_L_SEQ = gen_legendre_seq(10223);
    }
    int8_t *code = (int8_t *)sdr_malloc(N);
    
    for (int t = 0; t < p - 1; t++) {
        code[t] = -L1C_L_SEQ[t] * L1C_L_SEQ[(t + w) % 10223];
    }
    for (int t = p - 1; t < p + 6; t++) {
        code[t] = ins_code[t - p + 1];
    }
    for (int t = p + 6; t < N; t++) {
        code[t] = -L1C_L_SEQ[t - 7] * L1C_L_SEQ[(t - 7 + w) % 10223];
    }
    return code;
}

// generate L1CP code ----------------------------------------------------------
static int8_t *gen_code_L1CP(int prn, int *N)
{
    if (prn < 1 || prn > 210) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!L1CP[prn-1]) {
        int8_t *code = gen_code_L1CPD(n, L1CP_weil_idx[prn-1],
            L1CP_ins_idx[prn-1]);
        L1CP[prn-1] = mod_code(code, n, BOC, 2); // BOC(1,1)
        sdr_free(code);
    }
    return L1CP[prn-1];
}

// generate L1CD code ----------------------------------------------------------
static int8_t *gen_code_L1CD(int prn, int *N)
{
    if (prn < 1 || prn > 210) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!L1CD[prn-1]) {
        int8_t *code = gen_code_L1CPD(n, L1CD_weil_idx[prn-1],
            L1CD_ins_idx[prn-1]);
        L1CD[prn-1] = mod_code(code, n, BOC, 2); // BOC(1,1)
        sdr_free(code);
    }
    return L1CD[prn-1];
}

// generate L1CP secondary code ([7]) ------------------------------------------
static int8_t *sec_code_L1CP(int prn, int *N)
{
    if (prn < 1 || prn > 210) {
        return NULL;
    }
    *N = 1800;
    if (!L1CO[prn-1]) {
        uint32_t tap1 = rev_reg(L1CO_S1_poly[prn-1] >> 1, 11);
        int8_t *code1 = LFSR(*N, rev_reg(L1CO_S1_init[prn-1], 11), tap1, 11);
        
        if (prn >= 64) {
            uint32_t tap2 = 0x005;
            int8_t *code2 = LFSR(*N, rev_reg(L1CO_S2_init[prn-64], 11), tap2, 11);
            for (int i = 0; i < *N; i++) {
                code1[i] *= -code2[i];
            }
            sdr_free(code2);
        }
        L1CO[prn-1] = code1;
    }
    return L1CO[prn-1];
}

// generate L2C code ([1]) ------------------------------------------------------
static int8_t *gen_code_L2C(int N, uint32_t R)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    
    for (int i = 0; i < N; i++) {
        code[i] = CHIP[R & 1];
        R = (R >> 1) ^ (0x494953C * (R & 1));
    }
    return code;
}

// generate L2CM code ([1]) ----------------------------------------------------
static int8_t *gen_code_L2CM(int prn, int *N)
{
    static const int8_t sub_carr[] = {-1, 0}; // TDM
    
    if ((prn < 1 || prn > 63) && (prn < 159 || prn > 210)) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!L2CM[prn-1]) {
        uint32_t R = (prn <= 63) ? L2CM_R_init_1[prn-1] : L2CM_R_init_2[prn-159];
        int8_t *code = gen_code_L2C(n, R);
        L2CM[prn-1] = mod_code(code, n, sub_carr, 2);
        sdr_free(code);
    }
    return L2CM[prn-1];
}

// generate L2CL code ([1]) ----------------------------------------------------
static int8_t *gen_code_L2CL(int prn, int *N)
{
    static const int8_t sub_carr[] = {0, 1}; // TDM
    
    if ((prn < 1 || prn > 63) && (prn < 159 || prn > 210)) {
        return NULL;
    }
    int n = 767250;
    *N = n * 2;
    if (!L2CL[prn-1]) {
        uint32_t R = (prn <= 63) ? L2CL_R_init_1[prn-1] : L2CL_R_init_2[prn-159];
        int8_t *code = gen_code_L2C(n, R);
        L2CL[prn-1] = mod_code(code, n, sub_carr, 2);
        sdr_free(code);
    }
    return L2CL[prn-1];
}

// generate L5 XA code ---------------------------------------------------------
static int8_t *gen_code_L5_XA(int N)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    int8_t *code1 = LFSR(8190, 0x1FFF, 0x001B, 13);
    memcpy(code, code1, 8190);
    memcpy(code + 8190, code1, N - 8190);
    sdr_free(code1);
    return code;
}

// generate L5 XB code ---------------------------------------------------------
static int8_t *gen_code_L5_XB(int N)
{
    return LFSR(N, 0x1FFF, 0x16E3, 13);
}

// generate L5I code ([2]) -----------------------------------------------------
static int8_t *gen_code_L5I(int prn, int *N)
{
    if (prn < 1 || prn > 210) {
        return NULL;
    }
    *N = 10230;
    if (!L5I[prn-1]) {
        if (!L5_XA) {
            L5_XA = gen_code_L5_XA(*N);
            L5_XB = gen_code_L5_XB(*N);
        }
        L5I[prn-1] = (int8_t *)sdr_malloc(*N);
        for (int i = 0; i < *N; i++) {
            L5I[prn-1][i] = -L5_XA[i] * L5_XB[(i + L5I_XB_adv[prn-1]) % (*N)];
        }
    }
    return L5I[prn-1];
}

// generate L5Q code ([2]) -----------------------------------------------------
static int8_t *gen_code_L5Q(int prn, int *N)
{
    if (prn < 1 || prn > 210) {
        return NULL;
    }
    *N = 10230;
    if (!L5Q[prn-1]) {
        if (!L5_XA) {
            L5_XA = gen_code_L5_XA(*N);
            L5_XB = gen_code_L5_XB(*N);
        }
        L5Q[prn-1] = (int8_t *)sdr_malloc(*N);
        for (int i = 0; i < *N; i++) {
            L5Q[prn-1][i] = -L5_XA[i] * L5_XB[(i + L5Q_XB_adv[prn-1]) % (*N)];
        }
    }
    return L5Q[prn-1];
}

// generate L5SI code ([15]) ---------------------------------------------------
static int8_t *gen_code_L5SI(int prn, int *N)
{
    if ((prn < 184 || prn > 189) && (prn < 205 || prn > 206)) {
        return NULL;
    }
    return gen_code_L5I(prn, N);
}

// generate L5SIV code ([15]) --------------------------------------------------
static int8_t *gen_code_L5SIV(int prn, int *N)
{
    return gen_code_L5SI(prn, N);
}

// generate L5SQ code ([15]) ---------------------------------------------------
static int8_t *gen_code_L5SQ(int prn, int *N)
{
    if ((prn < 184 || prn > 189) && (prn < 205 || prn > 206)) {
        return NULL;
    }
    return gen_code_L5Q(prn, N);
}

// generate L5SQV code ([15]) --------------------------------------------------
static int8_t *gen_code_L5SQV(int prn, int *N)
{
    return gen_code_L5SQ(prn, N);
}

// generate L5I secondary code ([2])--------------------------------------------
static int8_t *sec_code_L5I(int prn, int *N)
{
    *N = 10;
    return NH10;
}

// generate L5I SBAS secondary code --------------------------------------------
static int8_t *sec_code_L5I_SBAS(int prn, int *N)
{
    *N = 2;
    return MC;
}

// generate L5Q secondary code ([2]) -------------------------------------------
static int8_t *sec_code_L5Q(int prn, int *N)
{
    *N = 20;
    return NH20;
}

// generate L5Q SBAS secondary code --------------------------------------------
static int8_t *sec_code_L5Q_SBAS(int prn, int *N)
{
    *N = 2;
    return MC;
}

// generate L5SI secondary code ([15]) -----------------------------------------
static int8_t *sec_code_L5SI(int prn, int *N)
{
    static int8_t code[] = {1};
    
    if ((prn < 184 || prn > 189) && (prn < 205 || prn > 206)) {
        return NULL;
    }
    *N = 1;
    return code; // L5SI normal mode
}

// generate L5SIV secondary code ([15]) ----------------------------------------
static int8_t *sec_code_L5SIV(int prn, int *N)
{
    if ((prn < 184 || prn > 189) && (prn < 205 || prn > 206)) {
        return NULL;
    }
    return sec_code_L5I_SBAS(prn, N); // L5S verification mode
}

// generate L5SQ secondary code ([15]) -----------------------------------------
static int8_t *sec_code_L5SQ(int prn, int *N)
{
    if ((prn < 184 || prn > 189) && (prn < 205 || prn > 206)) {
        return NULL;
    }
    return sec_code_L5Q(prn, N);
}

// generate L5SQV secondary code ([15]) ----------------------------------------
static int8_t *sec_code_L5SQV(int prn, int *N)
{
    if ((prn < 184 || prn > 189) && (prn < 205 || prn > 206)) {
        return NULL;
    }
    return sec_code_L5Q_SBAS(prn, N); // L5S verification mode
}

// generate L6 code ------------------------------------------------------------
static int8_t *gen_code_L6(int N, uint32_t R)
{
    int8_t *code1 = LFSR(N, 0x3FF, 0x0F3, 10);
    int8_t *code2 = LFSR(N, rev_reg(R, 20), 0x00053, 20);
    int8_t *code = xor_code(code1, code2, N);
    sdr_free(code1);
    sdr_free(code2);
    return code;
}

// generate L6D code ([4]) -----------------------------------------------------
static int8_t *gen_code_L6D(int prn, int *N)
{
    static const int8_t sub_carr[] = {-1, 0}; // TDM
    
    if (prn < 193 || prn > 202) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!L6D[prn-193]) {
        int8_t *code = gen_code_L6(n, L6D_R_init[prn-193]);
        L6D[prn-193] = mod_code(code, n, sub_carr, 2);
        sdr_free(code);
    }
    return L6D[prn-193];
}

// generate L6E code ([4]) -----------------------------------------------------
static int8_t *gen_code_L6E(int prn, int *N)
{
    static const int8_t sub_carr[] = {0, -1}; // TDM
    
    if (prn < 203 || prn > 212) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!L6E[prn-203]) {
        int8_t *code = gen_code_L6(n, L6E_R_init[prn-203]);
        L6E[prn-203] = mod_code(code, n, sub_carr, 2);
        sdr_free(code);
    }
    return L6E[prn-203];
}

// generate GLONASS C/A code ---------------------------------------------------
static int8_t *gen_code_GLO_CA(int N)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    uint32_t R = 0x1FF;
    
    for (int i = 0; i < N; i++) {
        code[i] = CHIP[(R >> 2) & 1];
        R = (sdr_xor_bits(R & 0x011) << 8) | (R >> 1);
    }
    return code;
}

// generate G1CA code ([14]) ---------------------------------------------------
static int8_t *gen_code_G1CA(int prn, int *N)
{
    if (prn < -7 || prn > 6) { // FCN
        return NULL;
    }
    *N = 511;
    if (!G1CA[0]) {
        G1CA[0] = gen_code_GLO_CA(*N);
    }
    return G1CA[0];
}

// generate G2CA code ([14]) ---------------------------------------------------
static int8_t *gen_code_G2CA(int prn, int *N)
{
    return gen_code_G1CA(prn, N);
}

// generate G1OCD code ([19]) --------------------------------------------------
static int8_t *gen_code_G1OCD(int prn, int *N)
{
   static const int8_t sub_carr[] = {-1, 0}; // TDM
   
   if (prn < 0 || prn > 63) {
       return NULL;
   }
   int n = 1023;
   *N = n * 2;
   if (!G1OCD[prn]) {
       int8_t *DC1 = LFSR(n, 0x0C8, 0x009, 10);
       int8_t *DC2 = LFSR(n, prn, 0x08B, 10);
       int8_t *code = xor_code(DC1, DC2, n);
       G1OCD[prn] = mod_code(code, n, sub_carr, 2);
       sdr_free(DC1);
       sdr_free(DC2);
       sdr_free(code);
   }
   return G1OCD[prn];
}

// generate G1OCP code ([19]) -------------------------------------------------
static int8_t *gen_code_G1OCP(int prn, int *N)
{
   static const int8_t sub_carr[] = {0, 0, -1, 1}; // BOC(1,1) + TDM
   
   if (prn < 0 || prn > 63) {
       return NULL;
   }
   int n = 4092;
   *N = n * 4;
   if (!G1OCP[prn]) {
       int8_t *DC1 = LFSR(n, 0x0C5, 0x053, 12);
       int8_t *DC2 = LFSR(n, prn, 0x21, 6);
       int8_t *code = xor_code(DC1, DC2, n);
       G1OCP[prn] = mod_code(code, n, sub_carr, 4);
       sdr_free(DC1);
       sdr_free(DC2);
       sdr_free(code);
   }
   return G1OCP[prn];
}

// generate G2OCP code ([20]) --------------------------------------------------
static int8_t *gen_code_G2OCP(int prn, int *N)
{
   static const int8_t sub_carr[] = {0, 0, -1, 1}; // BOC(1,1) + TDM
   
   if (prn < 0 || prn > 63) {
       return NULL;
   }
   int n = 10230;
   *N = n * 4;
   if (!G2OCP[prn]) {
       int8_t *DC1 = LFSR(n, 0x0D38, 0x0443, 14);
       int8_t *DC2 = LFSR(n, prn + 64, 0x03, 7);
       int8_t *code = xor_code(DC1, DC2, n);
       G2OCP[prn] = mod_code(code, n, sub_carr, 4);
       sdr_free(DC1);
       sdr_free(DC2);
       sdr_free(code);
   }
   return G2OCP[prn];
}

// generate G3OC DC1 code ([17]) -----------------------------------------------
static int8_t *gen_code_G3OC_DC1(int N)
{
   if (!G3OC_DC1) {
       G3OC_DC1 = LFSR(N, 0x0D38, 0x0443, 14);
   }
   return G3OC_DC1;
}

// generate G3OCD code ([17]) --------------------------------------------------
static int8_t *gen_code_G3OCD(int prn, int *N)
{
   if (prn < 0 || prn > 63) {
       return NULL;
   }
   *N = 10230;
   if (!G3OCD[prn]) {
       int8_t *DC1 = gen_code_G3OC_DC1(*N);
       int8_t *DC2 = LFSR(*N, prn, 0x03, 7);
       G3OCD[prn] = xor_code(DC1, DC2, *N);
       sdr_free(DC2);
   }
   return G3OCD[prn];
}

// generate G3OCP code ---------------------------------------------------------
static int8_t *gen_code_G3OCP(int prn, int *N)
{
   if (prn < 0 || prn > 63) {
       return NULL;
   }
   *N = 10230;
   if (!G3OCP[prn]) {
       int8_t *DC1 = gen_code_G3OC_DC1(*N);
       int8_t *DC3 = LFSR(*N, prn + 64, 0x03, 7);
       G3OCP[prn] = xor_code(DC1, DC3, *N);
       sdr_free(DC3);
   }
   return G3OCP[prn];
}

// generate G1CA secondary code ------------------------------------------------
static int8_t *sec_code_G1CA(int prn, int *N)
{
    static int8_t code[] = {1};
    
    if (prn < -7 || prn > 6) { // FCN
        return NULL;
    }
    if (prn % 2 == 0) { // even FCN
        *N = 1;
        return code;
    }
    else { // odd FCN
        *N = 2;
        return MC;
    }
}

// generate G2CA secondary code ------------------------------------------------
static int8_t *sec_code_G2CA(int prn, int *N)
{
    return sec_code_G1CA(prn, N);
}

// generate G1OCD secondary code [19] ------------------------------------------
static int8_t *sec_code_G1OCD(int prn, int *N)
{
    *N = (int)sizeof(MC);
    return MC;
}

// generate G2OCP secondary code [20] ------------------------------------------
static int8_t *sec_code_G2OCP(int prn, int *N)
{
    *N = (int)sizeof(G2OCP_OC2);
    return G2OCP_OC2;
}

// generate G3OCD secondary code ([17]) ----------------------------------------
static int8_t *sec_code_G3OCD(int prn, int *N)
{
    if (prn < 0 || prn > 63) {
        return NULL;
    }
    *N = (int)sizeof(BC);
    return BC;
}

// generate G3OCP secondary code ([17]) ----------------------------------------
static int8_t *sec_code_G3OCP(int prn, int *N)
{
    if (prn < 0 || prn > 63) {
        return NULL;
    }
    *N = (int)sizeof(NH10);
    return NH10;
}

// generate E1B code ([5]) -----------------------------------------------------
static int8_t *gen_code_E1B(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    int n = 4092;
    *N = n * 2;
    if (!E1B[prn-1]) {
        int8_t *code = read_code_hex(code_gal_E1B[prn-1], n);
        E1B[prn-1] = mod_code(code, n, BOC, 2); // BOC(1,1) instead of CBOC
        sdr_free(code);
    }
    return E1B[prn-1];
}

// generate E1C code ([5]) -----------------------------------------------------
static int8_t *gen_code_E1C(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    int n = 4092;
    *N = n * 2;
    if (!E1C[prn-1]) {
        int8_t *code = read_code_hex(code_gal_E1C[prn-1], n);
        E1C[prn-1] = mod_code(code, n, BOC, 2); // BOC(1,1) instead of CBOC
        sdr_free(code);
    }
    return E1C[prn-1];
}

// generate E1C secondary code ([5]) -------------------------------------------
static int8_t *sec_code_E1C(int prn, int *N)
{
    *N = 25;
    if (!E1CS) {
        E1CS = read_code_hex(code_gal_CS25, *N);
    }
    return E1CS;
}

// generate E5 code X1 ---------------------------------------------------------
static int8_t *gen_code_E5_X1(int N, uint32_t tap)
{
    return LFSR(N, 0x3FFF, rev_reg(tap >> 1, 14), 14);
}

// generate E5 code X2 ---------------------------------------------------------
static int8_t *gen_code_E5_X2(int N, uint32_t tap, uint32_t R)
{
    return LFSR(N, rev_reg(R, 14), rev_reg(tap >> 1, 14), 14);
}

// generate E5AI code ([5]) ----------------------------------------------------
static int8_t *gen_code_E5AI(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    *N = 10230;
    if (!E5AI[prn-1]) {
        int8_t *code1 = gen_code_E5_X1(*N, 040503);
        int8_t *code2 = gen_code_E5_X2(*N, 050661, E5AI_X2_init[prn-1]);
        E5AI[prn-1] = xor_code(code1, code2, *N);
        sdr_free(code1);
        sdr_free(code2);
    }
    return E5AI[prn-1];
}

// generate E5AI secondary code ([5]) ------------------------------------------
static int8_t *sec_code_E5AI(int prn, int *N)
{
    *N = 20;
    if (!E5AIS) {
        E5AIS = read_code_hex(code_gal_CS20, *N);
    }
    return E5AIS;
}

// generate E5AQ code ([5]) ----------------------------------------------------
static int8_t *gen_code_E5AQ(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    *N = 10230;
    if (!E5AQ[prn-1]) {
        int8_t *code1 = gen_code_E5_X1(*N, 040503);
        int8_t *code2 = gen_code_E5_X2(*N, 050661, E5AQ_X2_init[prn-1]);
        E5AQ[prn-1] = xor_code(code1, code2, *N);
        sdr_free(code1);
        sdr_free(code2);
    }
    return E5AQ[prn-1];
}

// generate E5AQ secondary code ([5]) ------------------------------------------
static int8_t *sec_code_E5AQ(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
       return NULL;
    }
    *N = 100;
    if (!E5AQS[prn-1]) {
        E5AQS[prn-1] = read_code_hex(code_gal_CS100[prn-1], *N);
    }
    return E5AQS[prn-1];
}

// generate E5BI code ([5]) ----------------------------------------------------
static int8_t *gen_code_E5BI(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    *N = 10230;
    if (!E5BI[prn-1]) {
        int8_t *code1 = gen_code_E5_X1(*N, 064021);
        int8_t *code2 = gen_code_E5_X2(*N, 051445, E5BI_X2_init[prn-1]);
        E5BI[prn-1] = xor_code(code1, code2, *N);
        sdr_free(code1);
        sdr_free(code2);
    }
    return E5BI[prn-1];
}

// generate E5BQ code ----------------------------------------------------------
static int8_t *gen_code_E5BQ(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    *N = 10230;
    if (!E5BQ[prn-1]) {
        int8_t *code1 = gen_code_E5_X1(*N, 064021);
        int8_t *code2 = gen_code_E5_X2(*N, 043143, E5BQ_X2_init[prn-1]);
        E5BQ[prn-1] = xor_code(code1, code2, *N);
        sdr_free(code1);
        sdr_free(code2);
    }
    return E5BQ[prn-1];
}

// generate E5BI secondary code ([5]) ------------------------------------------
static int8_t *sec_code_E5BI(int prn, int *N)
{
    *N = 4;
    if (!E5BIS) {
        E5BIS = read_code_hex(code_gal_CS4, *N);
    }
    return E5BIS;
}

// generate E5BQ secondary code ([5]) ------------------------------------------
static int8_t *sec_code_E5BQ(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    *N = 100;
    if (!E5BQS[prn-1]) {
        E5BQS[prn-1] = read_code_hex(code_gal_CS100[prn+49], *N);
    }
    return E5BQS[prn-1];
}

// generate E6B code ([6]) -----------------------------------------------------
static int8_t *gen_code_E6B(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    *N = 5115;
    if (!E6B[prn-1]) {
        E6B[prn-1] = read_code_hex(code_gal_E6B[prn-1], *N);
    }
    return E6B[prn-1];
}

// generate E6C code ([6]) -----------------------------------------------------
static int8_t *gen_code_E6C(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
        return NULL;
    }
    *N = 5115;
    if (!E6C[prn-1]) {
        E6C[prn-1] = read_code_hex(code_gal_E6C[prn-1], *N);
    }
    return E6C[prn-1];
}

// generate E6C secondary code -------------------------------------------------
static int8_t *sec_code_E6C(int prn, int *N)
{
    if (prn < 1 || prn > 50) {
       return NULL;
    }
    *N = 100;
    if (!E6CS[prn-1]) {
        E6CS[prn-1] = read_code_hex(code_gal_CS100[prn-1], *N);
    }
    return E6CS[prn-1];
}

// generate B1I G1 -------------------------------------------------------------
static int8_t *gen_code_B1I_G1(int N)
{
    return LFSR(N, 0x2AA, 0x41F, 11);
}

// generate B1I G2 -------------------------------------------------------------
static int8_t *gen_code_B1I_G2(int N, const uint8_t *ph_sel)
{
    uint32_t R = 0x2AA, tap = 0;
    int8_t *code = (int8_t *)sdr_malloc(N);
    
    for (int i = 0; i < 3 && ph_sel[i]; i++) {
        tap |= 1 << (11 - ph_sel[i]);
    }
    for (int i = 0; i < N; i++) {
        code[i] = CHIP[sdr_xor_bits(R & tap)];
        R = (sdr_xor_bits(R & 0x7CD) << 10) | (R >> 1);
    }
    return code;
}

// generate B1I code ([12]) ----------------------------------------------------
static int8_t *gen_code_B1I(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    *N = 2046;
    if (!B1I[prn-1]) {
        int8_t * code1 = gen_code_B1I_G1(*N);
        int8_t * code2 = gen_code_B1I_G2(*N, B1I_ph_sel[prn-1]);
        B1I[prn-1] = xor_code(code1, code2, *N);
        sdr_free(code1);
        sdr_free(code2);
    }
    return B1I[prn-1];
}

// generate B1I secondary code ([12]) ------------------------------------------
static int8_t *sec_code_B1I(int prn, int *N)
{
    static int8_t code[] = {1};
    
    if ((prn >= 1 && prn <= 5) || (prn >=59 && prn <= 63)) { // D2 (GEO)
       *N = 1;
       return code;
    }
    else if (prn >= 6 && prn <= 58) { // D1 (MEO/IGSO)
       *N = 20;
       return NH20;
    }
    return NULL;
}

// B1C Weil-code 10243 chips ----------------------------------------------------
static int8_t B1C_weil_code(int k, int w)
{
    if (!B1C_L_SEQ) {
        B1C_L_SEQ = gen_legendre_seq(10243);
    }
    return -B1C_L_SEQ[k] * B1C_L_SEQ[(k + w) % 10243];
}

// generate B1CD code ([8]) ----------------------------------------------------
static int8_t *gen_code_B1CD(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!B1CD[prn-1]) {
        int8_t *code = (int8_t *)sdr_malloc(n);
        for (int i = 0; i < n; i++) {
            int j = (i + B1CD_trunc_pnt[prn-1] - 1) % 10243;
            code[i] = B1C_weil_code(j, B1CD_ph_diff[prn-1]);
        }
        B1CD[prn-1] = mod_code(code, n, BOC, 2); // BOC(1,1)
        sdr_free(code);
    }
    return B1CD[prn-1];
}

// generate B1CP code ([8]) ----------------------------------------------------
static int8_t *gen_code_B1CP(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!B1CP[prn-1]) {
        int8_t *code = (int8_t *)sdr_malloc(n);
        for (int i = 0; i < n; i++) {
            int j = (i + B1CP_trunc_pnt[prn-1] - 1) % 10243;
            code[i] = B1C_weil_code(j, B1CP_ph_diff[prn-1]);
        }
        B1CP[prn-1] = mod_code(code, n, BOC, 2); // BOC(1,1) instead of QMBOC
        sdr_free(code);
    }
    return B1CP[prn-1];
}

// B1C Weil-code 3607 chip -----------------------------------------------------
static int8_t B1C_weil_code_s(int k, int w)
{
    if (!B1C_L_SEQ_S) {
        B1C_L_SEQ_S = gen_legendre_seq(3607);
    }
    return -B1C_L_SEQ_S[k] * B1C_L_SEQ_S[(k + w) % 3607];
}

// generate B1CP secondary code ([8]) ------------------------------------------
static int8_t *sec_code_B1CP(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    *N = 1800;
    if (!B1CS[prn-1]) {
        B1CS[prn-1] = (int8_t *)sdr_malloc(*N);
        for (int i = 0; i < *N; i++) {
            int j = (i + B1CS_trunc_pnt[prn-1] - 1) % 3607;
            B1CS[prn-1][i] = B1C_weil_code_s(j, B1CS_ph_diff[prn-1]);
        }
    }
    return B1CS[prn-1];
}

// generate B2I code -----------------------------------------------------------
static int8_t *gen_code_B2I(int prn, int *N)
{
    return gen_code_B1I(prn, N);
}

// generate B2I secondary code -------------------------------------------------
static int8_t *sec_code_B2I(int prn, int *N)
{
    return sec_code_B1I(prn, N);
}

// generate B2AD G1 code -------------------------------------------------------
static int8_t *gen_code_B2AD_G1(int N)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    int8_t *code1 = LFSR(8190, 0x1FFF, 0x1105, 13);
    memcpy(code, code1, 8190);
    memcpy(code + 8190, code1, N - 8190);
    sdr_free(code1);
    return code;
}

// generate B2AD G2 code -------------------------------------------------------
static int8_t *gen_code_B2AD_G2(int N, uint32_t R)
{
    return LFSR(N, R, 0x0517, 13);
}

// generate B2AD code ([9]) ----------------------------------------------------
static int8_t *gen_code_B2AD(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    *N = 10230;
    if (!B2AD[prn-1]) {
        if (!B2AD_G1) {
            B2AD_G1 = gen_code_B2AD_G1(*N);
        }
        int8_t *B2AD_G2 = gen_code_B2AD_G2(*N, B2AD_G2_init[prn-1]);
        B2AD[prn-1] = xor_code(B2AD_G1, B2AD_G2, *N);
        sdr_free(B2AD_G2);
    }
    return B2AD[prn-1];
}

// generate B2AD secondary code ------------------------------------------------
static int8_t *sec_code_B2AD(int prn, int *N)
{
    static int8_t code[] = {-1, -1, -1, 1, -1};
    
    *N = 5;
    return code;
}

// generate B2AP G1 code -------------------------------------------------------
static int8_t *gen_code_B2AP_G1(int N)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    int8_t *code1 = LFSR(8190, 0x1FFF, 0x04C1, 13);
    memcpy(code, code1, 8190);
    memcpy(code + 8190, code1, N - 8190);
    sdr_free(code1);
    return code;
}

// generate B2AP G2 code -------------------------------------------------------
static int8_t *gen_code_B2AP_G2(int N, uint32_t R)
{
    return LFSR(N, R, 0x1163, 13);
}

// generate B2AP code ([9]) ----------------------------------------------------
static int8_t *gen_code_B2AP(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    *N = 10230;
    if (!B2AP[prn-1]) {
        if (!B2AP_G1) {
            B2AP_G1 = gen_code_B2AP_G1(*N);
        }
        int8_t *B2AP_G2 = gen_code_B2AP_G2(*N, B2AP_G2_init[prn-1]);
        B2AP[prn-1] = xor_code(B2AP_G1, B2AP_G2, *N);
        sdr_free(B2AP_G2);
    }
    return B2AP[prn-1];
}

// B2A Weil-code 1021 chip -----------------------------------------------------
static int8_t B2A_weil_code(int k, int w)
{
    if (!B2A_L_SEQ) {
        B2A_L_SEQ = gen_legendre_seq(1021);
    }
    return -B2A_L_SEQ[k] * B2A_L_SEQ[(k + w) % 1021];
}

// generate B2AP secondary code ([9]) ------------------------------------------
static int8_t *sec_code_B2AP(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    *N = 100;
    if (!B2AS[prn-1]) {
        B2AS[prn-1] = (int8_t *)sdr_malloc(*N);
        for (int i = 0; i < *N; i++) {
            int j = (i + B2AS_trunc_pnt[prn-1] - 1) % 1021;
            B2AS[prn-1][i] = B2A_weil_code(j, B2AS_ph_diff[prn-1]);
        }
    }
    return B2AS[prn-1];
}

// generate B2BI G1 code -------------------------------------------------------
static int8_t *gen_code_B2BI_G1(int N)
{
    int8_t * code1 = LFSR(8190, 0x1FFF, 0x1019, 13);
    int8_t * code = (int8_t *)sdr_malloc(N);
    memcpy(code, code1, 8190);
    memcpy(code + 8190, code1, N - 8190);
    sdr_free(code1);
    return code;
}

// generate B2BI G2 code -------------------------------------------------------
static int8_t *gen_code_B2BI_G2(int N, uint32_t R)
{
    return LFSR(N, R, 0x0693, 13);
}

// generate B2BI code ----------------------------------------------------------
static int8_t *gen_code_B2BI(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    *N = 10230;
    if (!B2BI[prn-1]) {
        if (!B2BI_G1) {
            B2BI_G1 = gen_code_B2BI_G1(*N);
        }
        int8_t *B2BI_G2 = gen_code_B2BI_G2(*N, B2BI_G2_init[prn-1]);
        B2BI[prn-1] = xor_code(B2BI_G1, B2BI_G2, *N);
        sdr_free(B2BI_G2);
    }
    return B2BI[prn-1];
}

// generate B3I G1 code --------------------------------------------------------
static int8_t *gen_code_B3I_G1(int N)
{
    int8_t *code = (int8_t *)sdr_malloc(N);
    int8_t *code1 = LFSR(8190, 0x1FFF, 0x1601, 13);
    memcpy(code, code1, 8190);
    memcpy(code + 8190, code1, N - 8190);
    sdr_free(code1);
    return code;
}

// generate B3I G2 code --------------------------------------------------------
static int8_t *gen_code_B3I_G2(int N, uint32_t R_init)
{
    return LFSR(N, R_init, 0x11DB, 13);
}

// generate B3I code ([13]) ----------------------------------------------------
static int8_t *gen_code_B3I(int prn, int *N)
{
    if (prn < 1 || prn > 63) {
        return NULL;
    }
    *N = 10230;
    if (!B3I[prn-1]) {
        if (!B3I_G1) {
            B3I_G1 = gen_code_B3I_G1(*N);
        }
        int8_t *B3I_G2 = gen_code_B3I_G2(*N, B3I_G2_init[prn-1]);
        B3I[prn-1] = xor_code(B3I_G1, B3I_G2, *N);
        sdr_free(B3I_G2);
    }
    return B3I[prn-1];
}

// generate B3I secondary code -------------------------------------------------
static int8_t *sec_code_B3I(int prn, int *N)
{
    return sec_code_B1I(prn, N);
}

// shift registers of I1S code ([18]) ------------------------------------------
static void shift_I1S(uint64_t *R0, uint64_t *R1, uint64_t *C)
{
    uint64_t R0A = (*R0<<50) ^ (*R0<<45) ^ (*R0<<40) ^ (*R0<<20) ^ (*R0<<10) ^ (*R0<<5) ^ *R0;
    uint64_t S2A = ((*R0<<50) ^ (*R0<<45) ^ (*R0<<40)) & ((*R0<<20) ^ (*R0<<10) ^ (*R0<<5) ^ *R0);
    uint64_t S2B = (((*R0<<50) ^ (*R0<<45)) & (*R0<<40)) ^ (((*R0<<20) ^ (*R0<<10)) & ((*R0<<5) ^ *R0));
    uint64_t S2C = ((*R0<<50) & (*R0<<45)) ^ ((*R0<<20) & (*R0<<10)) ^ ((*R0<<5) & *R0);
    uint64_t S2 = S2A ^ S2B ^ S2C;
    uint64_t R1A = S2 ^ (*R0<<40) ^ (*R0<<35) ^ (*R0<<30) ^ (*R0<<25) ^ (*R0<<15) ^ *R0;
    uint64_t R1B = (*R1<<50) ^ (*R1<<45) ^ (*R1<<40) ^ (*R1<<20) ^ (*R1<<10) ^ (*R1<<5) ^ *R1;
    *R0 = ((*R0<<1) & 0x7FFFFFFFFFFFFF) | ((R0A>>54) & 1);
    *R1 = ((*R1<<1) & 0x7FFFFFFFFFFFFF) | (((R1A ^ R1B)>>54) & 1);
    *C = ((*C<<1) & 0x1F) | ((*C>>4) & 1);
}

// generate I1SD code ([18]) ---------------------------------------------------
static int8_t *gen_code_I1SD(int prn, int *N)
{
    if (prn < 1 || prn > 14) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!I1SD[prn-1]) {
        int8_t *code = (int8_t *)sdr_malloc(n);
        uint64_t R0 = I1SD_R0_init[prn-1];
        uint64_t R1 = I1SD_R1_init[prn-1];
        uint64_t C = I1SD_C_init[prn-1];
        for (int i = 0; i < n; i++) {
            code[i] = CHIP[((C>>4) ^ (R1>>54)) & 1];
            shift_I1S(&R0, &R1, &C);
        }
        I1SD[prn-1] = mod_code(code, n, BOC, 2); // BOC(1,1)
        sdr_free(code);
    }
    return I1SD[prn-1];
}

// generate I1SP code ([18]) ---------------------------------------------------
static int8_t *gen_code_I1SP(int prn, int *N)
{
    if (prn < 1 || prn > 14) {
        return NULL;
    }
    int n = 10230;
    *N = n * 2;
    if (!I1SP[prn-1]) {
        int8_t *code = (int8_t *)sdr_malloc(n);
        uint64_t R0 = I1SP_R0_init[prn-1];
        uint64_t R1 = I1SP_R1_init[prn-1];
        uint64_t C = I1SP_C_init[prn-1];
        for (int i = 0; i < n; i++) {
            code[i] = CHIP[((C>>4) ^ (R1>>54)) & 1];
            shift_I1S(&R0, &R1, &C);
        }
        I1SP[prn-1] = mod_code(code, n, BOC, 2); // BOC(1,1)
        sdr_free(code);
    }
    return I1SP[prn-1];
}

// shift registers of I1S overlay code ([18]) ----------------------------------
static void shift_I1SO(uint16_t *R0, uint16_t *R1)
{
    uint16_t R0A = (*R0<<5) ^ (*R0<<2) ^ (*R0<<1) ^ *R0;
    uint16_t S2A = ((*R0<<5) ^ (*R0<<2)) & ((*R0<<1) ^ *R0);
    uint16_t S2B = ((*R0<<5) & (*R0<<2)) ^ ((*R0<<1) & *R0);
    uint16_t R1A = S2A ^ S2B ^ (*R0<<6) ^ (*R0<<3) ^ (*R0<<2) ^ *R0;
    uint16_t R1B = (*R1<<5) ^ (*R1<<2) ^ (*R1<<1) ^ *R1;
    *R0 = ((*R0<<1) & 0x3FF) | ((R0A>>9) & 1);
    *R1 = ((*R1<<1) & 0x3FF) | (((R1A ^ R1B)>>9) & 1);
}

// generate I1SP overlay code ([18]) -------------------------------------------
static int8_t *sec_code_I1SP(int prn, int *N)
{
    if (prn < 1 || prn > 14) {
        return NULL;
    }
    *N = 1800;
    if (!I1SPO[prn-1]) {
        uint16_t R0 = I1SPO_R0_init[prn-1];
        uint16_t R1 = I1SPO_R1_init[prn-1];
        I1SPO[prn-1] = (int8_t *)sdr_malloc(*N);
        for (int i = 0; i < *N; i++) {
            I1SPO[prn-1][i] = CHIP[(R1>>9) & 1];
            shift_I1SO(&R0, &R1);
        }
    }
    return I1SPO[prn-1];
}

// generate I5S code -----------------------------------------------------------
static int8_t *gen_code_I5S(int prn, int *N)
{
    if (prn < 1 || prn > 14) {
        return NULL;
    }
    *N = 1023;
    if (!I5S[prn-1]) {
        int32_t R_init = rev_reg(I5S_G2_init[prn-1], 10);
        int8_t *I5S_G1 = LFSR(*N, 0x3FF, 0x081, 10);
        int8_t *I5S_G2 = LFSR(*N, R_init, 0x197, 10);
        I5S[prn-1] = xor_code(I5S_G1, I5S_G2, *N);
        sdr_free(I5S_G1);
        sdr_free(I5S_G2);
    }
    return I5S[prn-1];
}

// generate ISS code -----------------------------------------------------------
static int8_t *gen_code_ISS(int prn, int *N)
{
    if (prn < 1 || prn > 14) {
        return NULL;
    }
    *N = 1023;
    if (!ISS[prn-1]) {
        int32_t R_init = rev_reg(ISS_G2_init[prn-1], 10);
        int8_t *ISS_G1 = LFSR(*N, 0x3FF, 0x081, 10);
        int8_t *ISS_G2 = LFSR(*N, R_init, 0x197, 10);
        ISS[prn-1] = xor_code(ISS_G1, ISS_G2, *N);
        sdr_free(ISS_G1);
        sdr_free(ISS_G2);
    }
    return ISS[prn-1];
}

// generate primary code -------------------------------------------------------
static int8_t *gen_code(const char *sig, int prn, int *N)
{
    char Sig[16];
    
    sig_upper(sig, Sig);
    
    if (!strcmp(Sig, "L1CA")) {
        return gen_code_L1CA(prn, N);
    }
    else if (!strcmp(Sig, "L1S")) {
        return gen_code_L1S(prn, N);
    }
    else if (!strcmp(Sig, "L1CB")) {
        return gen_code_L1CB(prn, N);
    }
    else if (!strcmp(Sig, "L1CP")) {
        return gen_code_L1CP(prn, N);
    }
    else if (!strcmp(Sig, "L1CD")) {
        return gen_code_L1CD(prn, N);
    }
    else if (!strcmp(Sig, "L2CM")) {
        return gen_code_L2CM(prn, N);
    }
    else if (!strcmp(Sig, "L2CL")) {
        return gen_code_L2CL(prn, N);
    }
    else if (!strcmp(Sig, "L5I")) {
        return gen_code_L5I(prn, N);
    }
    else if (!strcmp(Sig, "L5Q")) {
        return gen_code_L5Q(prn, N);
    }
    else if (!strcmp(Sig, "L5SI")) {
        return gen_code_L5SI(prn, N);
    }
    else if (!strcmp(Sig, "L5SIV")) {
        return gen_code_L5SIV(prn, N);
    }
    else if (!strcmp(Sig, "L5SQ")) {
        return gen_code_L5SQ(prn, N);
    }
    else if (!strcmp(Sig, "L5SQV")) {
        return gen_code_L5SQV(prn, N);
    }
    else if (!strcmp(Sig, "L6D")) {
        return gen_code_L6D(prn, N);
    }
    else if (!strcmp(Sig, "L6E")) {
        return gen_code_L6E(prn, N);
    }
    else if (!strcmp(Sig, "G1CA")) {
        return gen_code_G1CA(prn, N);
    }
    else if (!strcmp(Sig, "G2CA")) {
        return gen_code_G2CA(prn, N);
    }
    else if (!strcmp(Sig, "G1OCD")) {
        return gen_code_G1OCD(prn, N);
    }
    else if (!strcmp(Sig, "G1OCP")) {
        return gen_code_G1OCP(prn, N);
    }
    else if (!strcmp(Sig, "G2OCP")) {
        return gen_code_G2OCP(prn, N);
    }
    else if (!strcmp(Sig, "G3OCD")) {
        return gen_code_G3OCD(prn, N);
    }
    else if (!strcmp(Sig, "G3OCP")) {
        return gen_code_G3OCP(prn, N);
    }
    else if (!strcmp(Sig, "E1B")) {
        return gen_code_E1B(prn, N);
    }
    else if (!strcmp(Sig, "E1C")) {
        return gen_code_E1C(prn, N);
    }
    else if (!strcmp(Sig, "E5AI")) {
        return gen_code_E5AI(prn, N);
    }
    else if (!strcmp(Sig, "E5AQ")) {
        return gen_code_E5AQ(prn, N);
    }
    else if (!strcmp(Sig, "E5BI")) {
        return gen_code_E5BI(prn, N);
    }
    else if (!strcmp(Sig, "E5BQ")) {
        return gen_code_E5BQ(prn, N);
    }
    else if (!strcmp(Sig, "E6B")) {
        return gen_code_E6B(prn, N);
    }
    else if (!strcmp(Sig, "E6C")) {
        return gen_code_E6C(prn, N);
    }
    else if (!strcmp(Sig, "B1I")) {
        return gen_code_B1I(prn, N);
    }
    else if (!strcmp(Sig, "B1CD")) {
        return gen_code_B1CD(prn, N);
    }
    else if (!strcmp(Sig, "B1CP")) {
        return gen_code_B1CP(prn, N);
    }
    else if (!strcmp(Sig, "B2I")) {
        return gen_code_B2I(prn, N);
    }
    else if (!strcmp(Sig, "B2AD")) {
        return gen_code_B2AD(prn, N);
    }
    else if (!strcmp(Sig, "B2AP")) {
        return gen_code_B2AP(prn, N);
    }
    else if (!strcmp(Sig, "B2BI")) {
        return gen_code_B2BI(prn, N);
    }
    else if (!strcmp(Sig, "B3I")) {
        return gen_code_B3I(prn, N);
    }
    else if (!strcmp(Sig, "I1SD")) {
        return gen_code_I1SD(prn, N);
    }
    else if (!strcmp(Sig, "I1SP")) {
        return gen_code_I1SP(prn, N);
    }
    else if (!strcmp(Sig, "I5S")) {
        return gen_code_I5S(prn, N);
    }
    else if (!strcmp(Sig, "ISS")) {
        return gen_code_ISS(prn, N);
    }
    return NULL;
}

//------------------------------------------------------------------------------
//  Generate primary code.
//
//  args:
//      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
//      prn      (I) PRN number
//      N        (O) Length of primary code
//
//  return:
//      Primary code as int8_t array (-1 or 1)
//      (sub-carrier modulated for BOC or zero-padded for TDM)
//
int8_t *sdr_gen_code(const char *sig, int prn, int *N)
{
    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    
    pthread_mutex_lock(&mtx);
    int8_t *code = gen_code(sig, prn, N);
    pthread_mutex_unlock(&mtx);
    
    return code;
}

// generate secondary (overlay) code -------------------------------------------
static int8_t *sec_code(const char *sig, int prn, int *N)
{
    static int8_t code[] = {1};
    char Sig[16];
    
    sig_upper(sig, Sig);
    
    if (!strcmp(Sig, "L1CA") || !strcmp(Sig, "L1S" ) || !strcmp(Sig, "L1CB") ||
        !strcmp(Sig, "L1CD") || !strcmp(Sig, "L2CM") || !strcmp(Sig, "L2CL") ||
        !strcmp(Sig, "L6D" ) || !strcmp(Sig, "G1OCP") || !strcmp(Sig, "L6E" ) ||
        !strcmp(Sig, "E1B" ) || !strcmp(Sig, "E6B" ) || !strcmp(Sig, "B1CD") ||
        !strcmp(Sig, "B2BI") || !strcmp(Sig, "I1SD") || !strcmp(Sig, "I5S" ) ||
        !strcmp(Sig, "ISS" )) {
        *N = 1;
        return code;
    }
    else if (!strcmp(Sig, "L1CP")) {
        return sec_code_L1CP(prn, N);
    }
    else if (!strcmp(Sig, "L5I")) {
        if (prn >= 120 && prn <=158) {
            return sec_code_L5I_SBAS(prn, N);
        }
        else {
            return sec_code_L5I(prn, N);
        }
    }
    else if (!strcmp(Sig, "L5Q")) {
        if (prn >= 120 && prn <=158) {
            return sec_code_L5Q_SBAS(prn, N);
        }
        else {
            return sec_code_L5Q(prn, N);
        }
    }
    else if (!strcmp(Sig, "L5SI")) {
        return sec_code_L5SI(prn, N);
    }
    else if (!strcmp(Sig, "L5SIV")) {
        return sec_code_L5SIV(prn, N);
    }
    else if (!strcmp(Sig, "L5SQ")) {
        return sec_code_L5SQ(prn, N);
    }
    else if (!strcmp(Sig, "L5SQV")) {
        return sec_code_L5SQV(prn, N);
    }
    else if (!strcmp(Sig, "G1CA")) {
        return sec_code_G1CA(prn, N);
    }
    else if (!strcmp(Sig, "G2CA")) {
        return sec_code_G2CA(prn, N);
    }
    else if (!strcmp(Sig, "G1OCD")) {
        return sec_code_G1OCD(prn, N);
    }
    else if (!strcmp(Sig, "G2OCP")) {
        return sec_code_G2OCP(prn, N);
    }
    else if (!strcmp(Sig, "G3OCD")) {
        return sec_code_G3OCD(prn, N);
    }
    else if (!strcmp(Sig, "G3OCP")) {
        return sec_code_G3OCP(prn, N);
    }
    else if (!strcmp(Sig, "E1C")) {
        return sec_code_E1C(prn, N);
    }
    else if (!strcmp(Sig, "E5AI")) {
        return sec_code_E5AI(prn, N);
    }
    else if (!strcmp(Sig, "E5AQ")) {
        return sec_code_E5AQ(prn, N);
    }
    else if (!strcmp(Sig, "E5BI")) {
        return sec_code_E5BI(prn, N);
    }
    else if (!strcmp(Sig, "E5BQ")) {
        return sec_code_E5BQ(prn, N);
    }
    else if (!strcmp(Sig, "E6C")) {
        return sec_code_E6C(prn, N);
    }
    else if (!strcmp(Sig, "B1I")) {
        return sec_code_B1I(prn, N);
    }
    else if (!strcmp(Sig, "B1CP")) {
        return sec_code_B1CP(prn, N);
    }
    else if (!strcmp(Sig, "B2I")) {
        return sec_code_B2I(prn, N);
    }
    else if (!strcmp(Sig, "B2AD")) {
        return sec_code_B2AD(prn, N);
    }
    else if (!strcmp(Sig, "B2AP")) {
        return sec_code_B2AP(prn, N);
    }
    else if (!strcmp(Sig, "B3I")) {
        return sec_code_B3I(prn, N);
    }
    else if (!strcmp(Sig, "I1SP")) {
        return sec_code_I1SP(prn, N);
    }
    *N = 0;
    return NULL;
}

//------------------------------------------------------------------------------
//  Generate secondary (overlay) code.
//
//  args:
//      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
//      prn      (I) PRN number
//      N        (O) Length of secondary code
//
//  return:
//      Secondary code as int8_t array (-1 or 1)
//
int8_t *sdr_sec_code(const char *sig, int prn, int *N)
{
    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    
    pthread_mutex_lock(&mtx);
    int8_t *code = sec_code(sig, prn, N);
    pthread_mutex_unlock(&mtx);
    
    return code;
}

//------------------------------------------------------------------------------
//  Get primary code cycle (period).
//
//  args:
//      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
//
//  returns:
//      Primary code cycle (period) (s) (0.0: error)
//
double sdr_code_cyc(const char *sig)
{
    char Sig[16];
    
    sig_upper(sig, Sig);
    
    if (!strcmp(Sig, "L1CA") || !strcmp(Sig, "L1CB") || !strcmp(Sig, "L1S" ) ||
        !strcmp(Sig, "L5I" ) || !strcmp(Sig, "L5Q" ) || !strcmp(Sig, "L5SI") ||
        !strcmp(Sig, "L5SIV") || !strcmp(Sig, "L5SQ") || !strcmp(Sig, "L5SQV") ||
        !strcmp(Sig, "G1CA") || !strcmp(Sig, "G2CA") || !strcmp(Sig, "G3OCD") ||
        !strcmp(Sig, "G3OCP") || !strcmp(Sig, "E5AI") || !strcmp(Sig, "E5AQ") ||
        !strcmp(Sig, "E5BI") || !strcmp(Sig, "E5BQ") || !strcmp(Sig, "E6B" ) ||
        !strcmp(Sig, "E6C" ) || !strcmp(Sig, "B1I" ) || !strcmp(Sig, "B2I" ) ||
        !strcmp(Sig, "B2AD") || !strcmp(Sig, "B2AP") || !strcmp(Sig, "B2BI") ||
        !strcmp(Sig, "B3I" ) || !strcmp(Sig, "I5S" ) || !strcmp(Sig, "ISS" )) {
        return 1e-3;
    }
    else if (!strcmp(Sig, "G1OCD")) {
        return 2e-3;
    }
    else if (!strcmp(Sig, "L6D" ) || !strcmp(Sig, "L6E" ) ||
        !strcmp(Sig, "E1B" ) || !strcmp(Sig, "E1C" )) {
        return 4e-3;
    }
    else if (!strcmp(Sig, "G1OCP")) {
        return 8e-3;
    }
    else if (!strcmp(Sig, "L1CP") || !strcmp(Sig, "L1CD") ||
        !strcmp(Sig, "B1CD") || !strcmp(Sig, "B1CP") || !strcmp(Sig, "I1SD") ||
        !strcmp(Sig, "I1SP")) {
        return 10e-3;
    }
    else if (!strcmp(Sig, "L2CM") || !strcmp(Sig, "G2OCP")) {
        return 20e-3;
    }
    else if (!strcmp(Sig, "L2CL")) {
        return 1500e-3;
    }
    return 0.0;
}

//------------------------------------------------------------------------------
//  Get primary code length.
//
//  args:
//      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
//
//  returns:
//      Primary code length (chips) (0: error)
//
int sdr_code_len(const char *sig)
{
    char Sig[16];
    
    sig_upper(sig, Sig);
    
    if (!strcmp(Sig, "L1CA") || !strcmp(Sig, "L1CB") || !strcmp(Sig, "L1S" ) ||
        !strcmp(Sig, "G1OCD") || !strcmp(Sig, "I5S" ) || !strcmp(Sig, "ISS" )) {
        return 1023;
    }
    else if (!strcmp(Sig, "L1CP") || !strcmp(Sig, "L1CD") ||
        !strcmp(Sig, "L2CM") || !strcmp(Sig, "L5I" ) || !strcmp(Sig, "L5Q" ) ||
        !strcmp(Sig, "L5SI") || !strcmp(Sig, "L5SIV") || !strcmp(Sig, "L5SQ") ||
        !strcmp(Sig, "L5SQV") || !strcmp(Sig, "L6D" ) || !strcmp(Sig, "L6E" ) ||
        !strcmp(Sig, "G2OCP") || !strcmp(Sig, "G3OCD") || !strcmp(Sig, "G3OCP") ||
        !strcmp(Sig, "E5AI") || !strcmp(Sig, "E5AQ") || !strcmp(Sig, "E5BI") ||
        !strcmp(Sig, "E5BQ") || !strcmp(Sig, "B1CD") || !strcmp(Sig, "B1CP") ||
        !strcmp(Sig, "B2AD") || !strcmp(Sig, "B2AP") || !strcmp(Sig, "B2BI") ||
        !strcmp(Sig, "B3I" ) || !strcmp(Sig, "I1SD") || !strcmp(Sig, "I1SP")) {
        return 10230;
    }
    else if (!strcmp(Sig, "L2CL")) {
        return 767250;
    }
    else if (!strcmp(Sig, "E6B" ) || !strcmp(Sig, "E6C" )) {
        return 5115;
    }
    else if (!strcmp(Sig, "E1B" ) || !strcmp(Sig, "E1C" ) ||
             !strcmp(Sig, "G1OCP")) {
        return 4092;
    }
    else if (!strcmp(Sig, "G1CA") || !strcmp(Sig, "G2CA")) {
        return 511;
    }
    else if (!strcmp(Sig, "B1I" ) || !strcmp(Sig, "B2I" )) {
        return 2046;
    }
    return 0;
}

//------------------------------------------------------------------------------
//  Get signal carrier frequency.
//
//  args:
//      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
//
//  return:
//      Signal carrier frequency (Hz) (0.0: error)
//
double sdr_sig_freq(const char *sig)
{
    char Sig[16];
    
    sig_upper(sig, Sig);
    
    if (!strcmp(Sig, "L1CA") || !strcmp(Sig, "L1CB") || !strcmp(Sig, "L1S" ) ||
        !strcmp(Sig, "E1B" ) || !strcmp(Sig, "E1C" ) || !strcmp(Sig, "L1CP") ||
        !strcmp(Sig, "L1CD") || !strcmp(Sig, "B1CD") || !strcmp(Sig, "B1CP") ||
        !strcmp(Sig, "I1SD") || !strcmp(Sig, "I1SP")) {
        return 1575.42e6;
    }
    else if (!strcmp(Sig, "L2CM") || !strcmp(Sig, "L2CL")) {
        return 1227.60e6;
    }
    else if (!strcmp(Sig, "L5I" ) || !strcmp(Sig, "L5Q" ) ||
        !strcmp(Sig, "L5SI") || !strcmp(Sig, "L5SIV") || !strcmp(Sig, "L5SQ") ||
        !strcmp(Sig, "L5SQV") || !strcmp(Sig, "E5AI") || !strcmp(Sig, "E5AQ") ||
        !strcmp(Sig, "B2AD") || !strcmp(Sig, "B2AP") || !strcmp(Sig, "I5S")) {
        return 1176.45e6;
    }
    else if (!strcmp(Sig, "E5BI") || !strcmp(Sig, "E5BQ") ||
             !strcmp(Sig, "B2I" ) || !strcmp(Sig, "B2BI")) {
        return 1207.14e6;
    }
    else if (!strcmp(Sig, "L6D" ) || !strcmp(Sig, "L6E" ) ||
             !strcmp(Sig, "E6B" ) || !strcmp(Sig, "E6C" )) {
        return 1278.75e6;
    }
    else if (!strcmp(Sig, "B1I" )) {
        return 1561.098e6;
    }
    else if (!strcmp(Sig, "B3I" )) {
        return 1268.52e6;
    }
    else if (!strcmp(Sig, "G1CA")) {
        return 1602.0e6;
    }
    else if (!strcmp(Sig, "G1OCD") || !strcmp(Sig, "G1OCP")) {
        return 1600.995e6;
    }
    else if (!strcmp(Sig, "G2CA")) {
        return 1246.0e6;
    }
    else if (!strcmp(Sig, "G2OCP")) {
        return 1248.0e6;
    }
    else if (!strcmp(Sig, "G3OCD") || !strcmp(Sig, "G3OCP")) {
        return 1202.025e6;
    }
    else if (!strcmp(Sig, "ISS" )) {
        return 2492.028e6;
    }
    return 0.0;
}

// get satellite ID for QZSS ([3],[4],[15]) ------------------------------------
static void sat_id_qzss(const char *sig, int prn, char *sat)
{
    static int sat_L1B[] = {4, 5, 8, 9};
    static int sat_L5S[] = {2, 4, 5, 0, 0, 3, 0, 0, 0, 0, 0, 7, 8};
    
    if (!strcmp(sig, "L1CB") && prn >= 203 && prn <= 206) {
        sprintf(sat, "J%02d", sat_L1B[prn-203]);
    }
    else if ((!strcmp(sig, "L1CA") || !strcmp(sig, "L1CD") ||
        !strcmp(sig, "L1CP") || !strcmp(sig, "L2CM") || !strcmp(sig, "L5I") ||
        !strcmp(sig, "L5Q") || !strcmp(sig, "L6D")) &&
        prn >= 193 && prn <= 202) {
        sprintf(sat, "J%02d", prn - 192);
    }
    else if (!strcmp(sig, "L1S") && prn >= 183 && prn <= 191) {
        sprintf(sat, "J%02d", prn - 182);
    }
    else if (!strncmp(sig, "L5S", 3) && prn >= 184 && prn <= 206 &&
        sat_L5S[prn-184]) {
        sprintf(sat, "J%02d", sat_L5S[prn-184]);
    }
    else if (!strcmp(sig, "L6E") && prn >= 203 && prn <= 212) {
        sprintf(sat, "J%02d", prn - 202);
    }
    else {
        sprintf(sat, "???");
    }
}
 
//------------------------------------------------------------------------------
//  Get satellite ID.
//
//  args:
//      sig      (I) Signal type as string ('L1CA', 'L1CB', 'L1CP', ....)
//      prn      (I) PRN number
//      sat      (O) Satellite ID ('???': unknown)
//
//  returns:
//      None
//
void sdr_sat_id(const char *sig, int prn, char *sat)
{
    if (sig[0] == 'L') {
        if (prn >= 1 && prn <= 63) { // GPS
            sprintf(sat, "G%02d", prn);
        }
        else if (prn >= 120 && prn <= 158) { // SBAS
            sprintf(sat, "S%02d", prn - 100);
        }
        else { // QZSS
            sat_id_qzss(sig, prn ,sat);
        }
    }
    else if (!strcmp(sig, "G1CA") || !strcmp(sig, "G2CA")) { // GLONASS (FDMA)
        sprintf(sat, "R%c%d", prn < 0 ? '-' : '+', prn < 0 ? -prn : prn);
    }
    else if (sig[0] == 'G') { // GLONASS (CDMA)
        sprintf(sat, "R%02d", prn);
    }
    else if (sig[0] == 'E') { // Galileo
        sprintf(sat, "E%02d", prn);
    }
    else if (sig[0] == 'B') { // BDS
        sprintf(sat, "C%02d", prn);
    }
    else if (sig[0] == 'I') { // NavIC
        sprintf(sat, "I%02d", prn);
    }
    else {
        sprintf(sat, "???");
    }
}

//------------------------------------------------------------------------------
//  Generate resampled and zero-padded code.
//
//  args:
//      code     (I) Code as int8_t array (-1 or 1)
//      len_code (I) Length of code (= 2 * n)
//      T        (I) Code cycle (period) (s)
//      coff     (I) Code offset (s)
//      fs       (I) Sampling frequency (Hz)
//      N        (I) Number of samples
//      Nz       (I) Number of zero-padding
//      code_res (O) Resampled and zero-padded code as float array (N + Nz)
//
//  return:
//      none
//
void sdr_res_code(const int8_t *code, int len_code, double T, double coff,
    double fs, int N, int Nz, float *code_res)
{
    double dx = len_code / T / fs;
    
    memset(code_res, 0, sizeof(float) * (N + Nz));
    
    for (int i = 0; i < N; i++) {
        code_res[i] = code[(int)((coff * fs + i) * dx) % len_code];
    }
}

//------------------------------------------------------------------------------
//  Generate resampled and zero-padded code FFT (DFT).
//
//  args:
//      code     (I) Code as int8_t array (-1 or 1)
//      len_code (I) Length of code
//      T        (I) Code cycle (period) (s)
//      coff     (I) Code offset (s)
//      fs       (I) Sampling frequency (Hz)
//      N        (I) Number of samples
//      Nz       (I) Number of zero-padding
//      code_fft (O) Resampled and zero-padded code DFT with conjugate as
//                   complex array (N + Nz)
//
//  return:
//      none
//
void sdr_gen_code_fft(const int8_t *code, int len_code, double T, double coff,
    double fs, int N, int Nz, sdr_cpx_t *code_fft)
{
    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    static fftwf_plan plan = NULL;
    static int N_plan = 0;
    float *code_res_f = (float *)sdr_malloc(sizeof(float) * (N + Nz));
    sdr_cpx_t *code_res = sdr_cpx_malloc(N + Nz);
    
    sdr_res_code(code, len_code, T, coff, fs, N, Nz, code_res_f);
    for (int i = 0; i < N + Nz; i++) {
        code_res[i][0] = code_res_f[i];
        code_res[i][1] = 0.0;
    }
    pthread_mutex_lock(&mtx);
    if (N + Nz != N_plan) {
        if (plan) {
            fftwf_destroy_plan(plan);
        }
        plan = fftwf_plan_dft_1d(N + Nz, code_res, code_fft, FFTW_FORWARD,
            FFTW_ESTIMATE);
        N_plan = N + Nz;
    }
    pthread_mutex_unlock(&mtx);
    
    fftwf_execute_dft(plan, code_res, code_fft);
    
    // complex conjugate
    for (int i = 0; i < N + Nz; i++) {
        code_fft[i][1] = -code_fft[i][1];
    }
    sdr_free(code_res_f);
    sdr_cpx_free(code_res);
}

